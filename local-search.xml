<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>acm1600</title>
    <link href="/2024/10/02/acm/"/>
    <url>/2024/10/02/acm/</url>
    
    <content type="html"><![CDATA[<h2 id="abc-364-f---range-connect-mst">1.ABC 364 F - Range ConnectMST</h2><h3 id="problem-statement">Problem Statement</h3><p>There is a graph with <span class="math inline">\(N + Q\)</span>vertices, numbered <span class="math inline">\(1, 2, \ldots, N +Q\)</span>. Initially, the graph has no edges.</p><p>For this graph, perform the following operation for <spanclass="math inline">\(i = 1, 2, \ldots, Q\)</span> in order:</p><ul><li>For each integer <span class="math inline">\(j\)</span> satisfying<span class="math inline">\(L_i \leq j \leq R_i\)</span>, add anundirected edge with cost <span class="math inline">\(C_i\)</span>between vertices <span class="math inline">\(N + i\)</span> and <spanclass="math inline">\(j\)</span>.</li></ul><p>Determine if the graph is connected after all operations arecompleted. If it is connected, find the cost of a minimum spanning treeof the graph.</p><p>A minimum spanning tree is a spanning tree with the smallest possiblecost, and the cost of a spanning tree is the sum of the costs of theedges used in the spanning tree.</p><h3 id="constraints">Constraints</h3><ul><li><span class="math inline">\(1 \leq N, Q \leq 2 \times10^5\)</span></li><li><span class="math inline">\(1 \leq L_i \leq R_i \leq N\)</span></li><li><span class="math inline">\(1 \leq C_i \leq 10^9\)</span></li><li>All input values are integers.</li></ul><h3 id="思路">思路</h3><p>首先容易想到按边权排序。我们默认每一次操作至少添加一次，那么我们可以将<spanclass="math inline">\(N+1\simN+Q\)</span>看成已经联通，我们可以初始状态看成<spanclass="math inline">\(N+1\)</span>个连通块，目标是使最后只剩下一个联通块。而对于具体的一次操作我们显然需要连接范围内所有联通块。</p><h4 id="利用set">利用set</h4><p>注意到每一个连通块连接的点是连续的。我们用set储存每个连通块最小的点的编号，每次操作可以二分快速找到连通块数量。具体细节看代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>  <span class="hljs-type">int</span> l, r, c;<br>  <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node&amp; u) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> c &lt; u.c; &#125;<br>&#125; a[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, q;<br>  cin &gt;&gt; n &gt;&gt; q;<br>  set&lt;<span class="hljs-type">int</span>&gt; st;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) st.<span class="hljs-built_in">insert</span>(i);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; ++i) cin &gt;&gt; a[i].l &gt;&gt; a[i].r &gt;&gt; a[i].c;<br>  <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + q);<br>  ll ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; ++i) &#123;<br>    <span class="hljs-keyword">auto</span> s = st.<span class="hljs-built_in">upper_bound</span>(a[i].l), e = st.<span class="hljs-built_in">upper_bound</span>(a[i].r);<br>    s--, e--;<br>    ll cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (s != e) &#123;<br>      s++;<br>      <span class="hljs-keyword">while</span> (s != e) &#123;<br>        <span class="hljs-keyword">auto</span> it = ++s;<br>        s--;<br>        st.<span class="hljs-built_in">erase</span>(s);<br>        s = it;<br>        cnt++;<br>      &#125;<br>      cnt++;<br>      st.<span class="hljs-built_in">erase</span>(e);<br>    &#125;<br>    ans += cnt * a[i].c;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) ans = <span class="hljs-number">-1</span>;<br>  cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="利用并查集">利用并查集</h4><p>原理和用set类似。</p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>  <span class="hljs-type">int</span> l, r, c;<br>  <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node&amp; u) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> c &lt; u.c; &#125;<br>&#125; a[N];<br><span class="hljs-type">int</span> pre[N];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">root</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> pre[x] = (pre[x] == x ? x : <span class="hljs-built_in">root</span>(pre[x])); &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, q;<br>  cin &gt;&gt; n &gt;&gt; q;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) pre[i] = i;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; ++i) cin &gt;&gt; a[i].l &gt;&gt; a[i].r &gt;&gt; a[i].c;<br>  <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + q);<br>  ll ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; ++i) &#123;<br>    <span class="hljs-keyword">auto</span> [l, r, c] = a[i];<br>    ans += c;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">root</span>(l) != <span class="hljs-built_in">root</span>(r)) ans += c, pre[<span class="hljs-built_in">root</span>(r)] = <span class="hljs-built_in">root</span>(r) - <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">root</span>(<span class="hljs-number">1</span>) != <span class="hljs-built_in">root</span>(n)) ans = <span class="hljs-number">-1</span>;<br>  cout &lt;&lt; ans;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="利用线段树">利用线段树</h4><p>我们维护一个数组<span class="math inline">\(t\)</span>，若<spanclass="math inline">\(i\)</span>与<spanclass="math inline">\(i+1\)</span>联通，则为0否则为1。那么，<spanclass="math inline">\([l,r]\)</span>的联通块数量为<spanclass="math inline">\([l,r)\)</span>的和加1。证明很容易，不多赘述。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>  <span class="hljs-type">int</span> l, r, c;<br>  <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node&amp; u) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> c &lt; u.c; &#125;<br>&#125; a[N];<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls p &lt;&lt; 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs p &lt;&lt; 1 | 1</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tree</span> &#123;<br>  ll l, r, s, lz, mlz;<br>&#125; t[N &lt;&lt; <span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">mo</span><span class="hljs-params">(ll x)</span> </span>&#123; <span class="hljs-keyword">return</span> (x + mod) % mod; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(ll p)</span> </span>&#123; t[p].s = <span class="hljs-built_in">mo</span>(t[ls].s + t[rs].s); &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(ll p, ll k, ll x)</span> </span>&#123;<br>  t[p].s = <span class="hljs-built_in">mo</span>(<span class="hljs-built_in">mo</span>(t[p].s * k) + <span class="hljs-built_in">mo</span>(x * (t[p].r - t[p].l + <span class="hljs-number">1</span>)));<br>  t[p].mlz = <span class="hljs-built_in">mo</span>(t[p].mlz * k);<br>  t[p].lz = <span class="hljs-built_in">mo</span>(<span class="hljs-built_in">mo</span>(t[p].lz * k) + x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(ll p)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (t[p].lz == <span class="hljs-number">0</span> &amp;&amp; t[p].mlz == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-built_in">update</span>(ls, t[p].mlz, t[p].lz);<br>  <span class="hljs-built_in">update</span>(rs, t[p].mlz, t[p].lz);<br>  t[p].lz = <span class="hljs-number">0</span>, t[p].mlz = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ll p, ll l, ll r)</span> </span>&#123;<br>  t[p] = &#123;l, r, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>  <span class="hljs-keyword">if</span> (l == r) &#123;<br>    t[p].s = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  ll mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">build</span>(ls, l, mid);<br>  <span class="hljs-built_in">build</span>(rs, mid + <span class="hljs-number">1</span>, r);<br>  <span class="hljs-built_in">push_up</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(ll p, ll l, ll r, ll k, ll x)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span> (l &lt;= t[p].l <span class="hljs-keyword">and</span> r &gt;= t[p].r) &#123;<br>    <span class="hljs-built_in">update</span>(p, k, x);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-built_in">push_down</span>(p);<br>  <span class="hljs-keyword">if</span> (l &lt;= t[ls].r) <span class="hljs-built_in">modify</span>(ls, l, r, k, x);<br>  <span class="hljs-keyword">if</span> (r &gt;= t[rs].l) <span class="hljs-built_in">modify</span>(rs, l, r, k, x);<br>  <span class="hljs-built_in">push_up</span>(p);<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll p, ll l, ll r)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (l &lt;= t[p].l <span class="hljs-keyword">and</span> r &gt;= t[p].r) <span class="hljs-keyword">return</span> t[p].s;<br><br>  <span class="hljs-built_in">push_down</span>(p);<br>  ll res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (l &lt;= t[ls].r) res = <span class="hljs-built_in">mo</span>(res + <span class="hljs-built_in">query</span>(ls, l, r));<br>  <span class="hljs-keyword">if</span> (r &gt;= t[rs].l) res = <span class="hljs-built_in">mo</span>(res + <span class="hljs-built_in">query</span>(rs, l, r));<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, q;<br>  cin &gt;&gt; n &gt;&gt; q;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; ++i) cin &gt;&gt; a[i].l &gt;&gt; a[i].r &gt;&gt; a[i].c;<br>  <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + q);<br>  <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<br>  ll ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; ++i) &#123;<br>    <span class="hljs-keyword">auto</span> [l, r, c] = a[i];<br>    ans += c * (<span class="hljs-number">1</span> + <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, l, r - <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, l, r - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>)) ans = <span class="hljs-number">-1</span>;<br>  cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="abc-361-f---x-ab">2.ABC 361 F - x = a^b</h2><h3 id="problem-statement-1">Problem Statement</h3><p>How many integers <span class="math inline">\(x\)</span> between<span class="math inline">\(1\)</span> and <spanclass="math inline">\(N\)</span>, inclusive, can be expressed as <spanclass="math inline">\(x = a^b\)</span> using some positive integer <spanclass="math inline">\(a\)</span> and a positive integer <spanclass="math inline">\(b\)</span> <strong>not less than <spanclass="math inline">\(2\)</span></strong>?</p><h3 id="constraints-1">Constraints</h3><ul><li>All input values are integers.</li><li><span class="math inline">\(1 \le N \le 10^{18}\)</span></li></ul><h3 id="方法一">方法一</h3><p>答案为 <span class="math display">\[\sum_{i=1}^{n} [i可以被表示为a^b]\]</span></p><p>注意到，一个数如果可以表示为<spanclass="math inline">\(a^{kb}\)</span>那么它一定也可以被表示为<spanclass="math inline">\(a^b\)</span>，那么我们可以先只考虑<spanclass="math inline">\(b\)</span>为质数。我们先排除1，注意到<spanclass="math inline">\(2^{60}&gt;10^{18}\)</span>，那么我们可以只考虑<spanclass="math inline">\(60\)</span>以内的质数，只有17个。设其为<spanclass="math inline">\(p_i\)</span>，我们令<spanclass="math inline">\(A_i\)</span>表示可以表示为<spanclass="math inline">\(a^{p_i}\)</span>的个数。那么答案显然为 <spanclass="math display">\[|A_1\cup A_2\cup \cdots\cup A_n|\]</span> 利用容斥原理显然可以解决。</p><p>但是由于精度问题，我们不能直接<code>pow(n,1.0/x)</code>解<spanclass="math inline">\(\sqrt[x]{n}\)</span>，或者解出来后在向左右分别枚举一下，python是可以解决的。但是c++不行。</p><p>但是因为这几个质数乘积要小于<spanclass="math inline">\(60\)</span>。实际需要解的数量是很少的，且<spanclass="math inline">\(x&gt;2\)</span>从1枚举也只需要<spanclass="math inline">\(1e6\)</span>，因此可以直接枚举。而<spanclass="math inline">\(x=2\)</span>时，也不能用<code>sqrt()</code>,得用<code>sqrtl()</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> pri[] = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">23</span>, <span class="hljs-number">29</span>, <span class="hljs-number">31</span>, <span class="hljs-number">37</span>, <span class="hljs-number">41</span>, <span class="hljs-number">43</span>, <span class="hljs-number">47</span>, <span class="hljs-number">53</span>, <span class="hljs-number">59</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nr</span><span class="hljs-params">(ll n, ll r)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (r == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrtl</span>(n);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pow</span>(i, r) &gt; n) &#123;<br>      <span class="hljs-keyword">return</span> i - <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  ll n;<br>  cin &gt;&gt; n;<br>  <span class="hljs-type">int</span> up = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (; up &lt; <span class="hljs-number">17</span>; ++up) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1ll</span> &lt;&lt; pri[up] &gt; n) <span class="hljs-keyword">break</span>;<br>  &#125;<br>  ll ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; (<span class="hljs-number">1ll</span> &lt;&lt; up); ++i) &#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, r = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">17</span>; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (i &gt;&gt; j &amp; <span class="hljs-number">1</span>) cnt++, r *= pri[j];<br>      <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">60</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">60</span>) &#123;<br>      ans += (cnt % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>) * (<span class="hljs-built_in">nr</span>(n, r) - <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; ans + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二">方法二</h3><p>不妨设<span class="math inline">\(f(x)\)</span>为<spanclass="math inline">\(2\sim n\)</span>仅可表示为<spanclass="math inline">\(a^x\)</span>的个数，<spanclass="math inline">\(g(x)\)</span>为可以表示为<spanclass="math inline">\(a^x\)</span>的个数。</p><p>那么显然有 <span class="math display">\[f(x)=g(x)-f(2x)-f(3x)\cdots\]</span> 从后向前递推即可。</p><p>到这里发现，前面的代码能过是<strong>运气好</strong>。因为<code>pow</code>还是会错。参考答案可以自己写个<code>pow</code>函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">safe_pow</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;<br>  ll res = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">0</span>; i &lt; b; i++) &#123;<br>    <span class="hljs-type">double</span> dres = res;<br>    dres *= a;<br>    <span class="hljs-keyword">if</span> (dres &gt; <span class="hljs-number">2e18</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">2e18</span>;<br>    &#125;<br>    res *= a;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nr</span><span class="hljs-params">(ll n, ll r)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (r == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrtl</span>(n);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">safe_pow</span>(i, r) &gt; n) &#123;<br>      <span class="hljs-keyword">return</span> i - <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-type">int</span> f[<span class="hljs-number">100</span>], g[<span class="hljs-number">100</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  ll n;<br>  cin &gt;&gt; n;<br>  ll ans = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">60</span>; ++i) g[i] = <span class="hljs-built_in">nr</span>(n, i) - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">60</span>; x &gt;= <span class="hljs-number">2</span>; --x) &#123;<br>    f[x] = g[x];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">2</span>; k * x &lt;= <span class="hljs-number">60</span>; ++k) f[x] -= f[k * x];<br>    ans += f[x];<br>  &#125;<br>  cout &lt;&lt; ans;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们也可以用二分来替换开根运算，保证精度。<del>但是懒得写</del></p><h2 id="abc362-f---perfect-matching-on-a-tree">3.ABC362 F - PerfectMatching on a Tree</h2><h3 id="problem-statement-2">Problem Statement</h3><p>You are given a tree <span class="math inline">\(T\)</span> with<span class="math inline">\(N\)</span> vertices. The vertices arenumbered <span class="math inline">\(1\)</span> to <spanclass="math inline">\(N\)</span>, and the <spanclass="math inline">\(i\)</span>-th edge <span class="math inline">\((1\leq i \leq N-1)\)</span> connects vertices <spanclass="math inline">\(u_i\)</span> and <spanclass="math inline">\(v_i\)</span> bidirectionally.</p><p>Using <span class="math inline">\(T\)</span>, define a complete graph<span class="math inline">\(G\)</span> with <spanclass="math inline">\(N\)</span> vertices as follows:</p><ul><li>The weight <span class="math inline">\(w(x,y)\)</span> of the edgebetween vertices <span class="math inline">\(x\)</span> and <spanclass="math inline">\(y\)</span> in <spanclass="math inline">\(G\)</span> is the shortest distance betweenvertices <span class="math inline">\(x\)</span> and <spanclass="math inline">\(y\)</span> in <spanclass="math inline">\(T\)</span>.</li></ul><p>Find one <strong>maximum weight maximum matching</strong> in <spanclass="math inline">\(G\)</span>. That is, find a set of <spanclass="math inline">\(\lfloor N/2 \rfloor\)</span> pairs of vertices<span class="math inline">\(M=\{(x_1,y_1),(x_2,y_2),\dots,(x_{\lfloorN/2 \rfloor},y_{\lfloor N/2 \rfloor})\}\)</span> such that each vertex<span class="math inline">\(1,2,\dots, N\)</span> appears in <spanclass="math inline">\(M\)</span> at most once, and <spanclass="math inline">\(\displaystyle \sum_{i=1}^{\lfloor N/2 \rfloor}w(x_i,y_i)\)</span> is maximized.</p><h3 id="constraints-2">Constraints</h3><ul><li><span class="math inline">\(2 \leq N \leq 2 \times10^5\)</span></li><li><span class="math inline">\(1 \leq u_i  &lt; v_i \leqN\)</span></li><li>The input graph is a tree.</li><li>All input values are integers.</li></ul><h3 id="思路-1">思路</h3><p>考虑计算一条边可能被计算的次数。易证，边<spanclass="math inline">\((x,y)\)</span>最多被计算<spanclass="math inline">\(\min(size_x,size_y)\)</span>次。考虑每一条边都能达到上界。</p><p>下面构造一种方案能够达到上界。</p><p>引入树的重心的概念：</p><p>树的重心是以其为根节点时的<strong>最大子树大小</strong>最小。下面给出一些性质。</p><ol type="1"><li>等价于最大子树大小不超过<spanclass="math inline">\(\frac{n}{2}\)</span>。</li><li>树最多2个重心，且此时树有偶数个节点，且重心两两相邻。</li><li>树中所有点到某个点的<strong>距离和</strong>中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。反过来，距离和最小的点一定是重心。</li><li>往树上增加或减少一个<strong>叶子</strong>，如果原节点数是奇数，那么重心可能<strong>增加</strong>一个，原重心<strong>仍是重心</strong>；如果原节点数是偶数，重心可能<strong>减少</strong>一个，另一个重心<strong>仍是重心</strong>。</li><li>两棵树通过连一条边组合成新树，则新树重心在原来两棵树的重心的连线上。</li></ol><p>我们以树的重心为根，其有若干子树。且我们每条路径的两个点分别在两个子树上。</p><p>那么假设边<span class="math inline">\((x,y)\)</span>且<spanclass="math inline">\(y\)</span>是<spanclass="math inline">\(x\)</span>的父亲。则有<spanclass="math inline">\(x\)</span>的子树所有节点所匹配的点形成的路径一定会经过<spanclass="math inline">\((x,y)\)</span>。</p><p>下面考虑如何构造这样的方案。</p><p>首先，若节点数为偶数，那么最后会子树会剩下一个节点，容易发现将其与根节点匹配即可。然后我们考虑如何找到不同子树的点。注意到每个子树大小小于等于<spanclass="math inline">\(\frac{n}{2}\)</span>，且每颗子树的dfs序连续，那么我们可以找dfs序为<spanclass="math inline">\((i,i+\frac{n}{2})\)</span>的两个点。</p><h4 id="代码">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; g[N];<br><span class="hljs-type">int</span> si[N], cen, n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> pre)</span> </span>&#123;<br>  si[x] = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; y : g[x]) &#123;<br>    <span class="hljs-keyword">if</span> (y == pre) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-built_in">dfs</span>(y, x);<br>    si[x] += si[y];<br>    mx = <span class="hljs-built_in">max</span>(mx, si[y]);<br>  &#125;<br>  mx = <span class="hljs-built_in">max</span>(mx, n - si[x]);<br>  <span class="hljs-keyword">if</span> (mx &lt;= n / <span class="hljs-number">2</span>) cen = x;<br>&#125;<br><br><span class="hljs-type">int</span> dfn[N], idx, hs[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> pre)</span> </span>&#123;<br>  dfn[x] = ++idx;<br>  hs[idx] = x;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; y : g[x]) &#123;<br>    <span class="hljs-keyword">if</span> (y == pre) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-built_in">dfs1</span>(y, x);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> x, y;<br>  cin &gt;&gt; n;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>    cin &gt;&gt; x &gt;&gt; y;<br>    g[x].<span class="hljs-built_in">push_back</span>(y);<br>    g[y].<span class="hljs-built_in">push_back</span>(x);<br>  &#125;<br>  <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">dfs1</span>(cen, cen);<br>  <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; ++i) cout &lt;&lt; hs[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; hs[i + n / <span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n / <span class="hljs-number">2</span>; ++i) cout &lt;&lt; hs[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; hs[i + n / <span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="shcpc">2024 SHCPC</h2><p>https://codeforces.com/gym/105229/attachments</p><h3 id="a.无线网络整点栅格统计">4. A.无线网络整点栅格统计</h3><p>已知正方形两点坐标<spanclass="math inline">\((x_1,y_1),(x_2,y_2)\)</span></p><p>令<code>dx=x2-x1,dy=y2-y1</code>，可以得到<code>x3=x1+dy,y3=y1-dx,x4=x3+dx,y4=y3+dy</code></p><h3 id="m.不共戴天">5. M.不共戴天</h3><p>注意到可以将其列成表格，</p><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>4</td><td>5</td><td>6</td></tr><tr><td>7</td><td>8</td><td>9</td></tr><tr><td>10</td><td>11</td><td>12</td></tr></tbody></table><p>那么所有横着连的不可能和竖着连的相同.且无法多连.枚举一排个数即可.</p><h2 id="d.-1-2-k-game博弈论">6. <strong>D. 1-2-KGame</strong>(博弈论)</h2><p>https://codeforces.com/contest/1194/problem/D 博弈论</p><p>我们可以列出每个位置的胜负情况.可发现会产生一个<spanclass="math inline">\(T=k+1\)</span>的循环.证明略.</p><h2 id="f---teleporting-takahashi-2-dp">7. <strong>F - TeleportingTakahashi 2</strong> (DP)</h2><p>https://atcoder.jp/contests/abc372/tasks/abc372_f DP</p><p>如果么没有多余的边,那么每次转移固定.且编号是可计算的.那么每次只需要,计算最多50次即可.</p><h3 id="code">code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, m, k;<br>  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>    <span class="hljs-type">int</span> x, y;<br>    cin &gt;&gt; x &gt;&gt; y;<br>    g.<span class="hljs-built_in">push_back</span>(&#123;x, y&#125;);<br>  &#125;<br>  <span class="hljs-keyword">auto</span> id = [&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> x) &#123; <span class="hljs-built_in">return</span> ((i - x) % n + n) % n == <span class="hljs-number">0</span> ? n : ((i - x) % n + n) % n; &#125;;<br>  f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, ff[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; ++i) &#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [x, y] : g) &#123;<br>      <span class="hljs-type">int</span> p = <span class="hljs-built_in">id</span>(y - <span class="hljs-number">1</span> == <span class="hljs-number">0</span> ? n : y - <span class="hljs-number">1</span>, i - <span class="hljs-number">1</span>);<br>      f[p] += ff[<span class="hljs-built_in">id</span>(x, i - <span class="hljs-number">1</span>)];<br>      f[p] %= mod;<br>      v.<span class="hljs-built_in">push_back</span>(p);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> x : v) ff[x] = f[x];<br>  &#125;<br>  ll ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) ans = (ans + f[i]) % mod;<br>  cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="g---add-and-multiply-queries树状数组">8.<strong>G - Add andMultiply Queries</strong>(树状数组)</h2><p>https://atcoder.jp/contests/abc368/tasks/abc368_g</p><p>注意到其不超过1e18，那么乘法最多不超过60次，因此大量<spanclass="math inline">\(b\)</span>数组是1，所以我们可以用<code>set</code>记录b数组非1的位置，并用树状数组维护区间和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; n;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i], <span class="hljs-built_in">add</span>(i, a[i]);<br>  set&lt;<span class="hljs-type">int</span>&gt; st;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    cin &gt;&gt; b[i];<br>    <span class="hljs-keyword">if</span> (b[i] &gt; <span class="hljs-number">1</span>) st.<span class="hljs-built_in">insert</span>(i);<br>  &#125;<br>  st.<span class="hljs-built_in">insert</span>(n + <span class="hljs-number">1</span>);<br>  <span class="hljs-type">int</span> q;<br>  cin &gt;&gt; q;<br>  <span class="hljs-keyword">while</span> (q--) &#123;<br>    <span class="hljs-type">int</span> op;<br>    cin &gt;&gt; op;<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-type">int</span> i, x;<br>      cin &gt;&gt; i &gt;&gt; x;<br>      <span class="hljs-built_in">add</span>(i, x - a[i]);<br>      a[i] = x;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-type">int</span> i, x;<br>      cin &gt;&gt; i &gt;&gt; x;<br>      <span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">count</span>(i)) st.<span class="hljs-built_in">erase</span>(i);<br>        b[i] = <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        b[i] = x;<br>        st.<span class="hljs-built_in">insert</span>(i);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-type">int</span> l, r;<br>      cin &gt;&gt; l &gt;&gt; r;<br>      ll ans = a[l++];<br>      <span class="hljs-comment">// cout &lt;&lt; ans &lt;&lt; endl;</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r;) &#123;<br>        <span class="hljs-type">int</span> up = <span class="hljs-built_in">min</span>(r, *st.<span class="hljs-built_in">lower_bound</span>(i));<br>        <span class="hljs-comment">//  cout &lt;&lt; up &lt;&lt; endl;</span><br>        ans += <span class="hljs-built_in">prefix</span>(up - <span class="hljs-number">1</span>) - <span class="hljs-built_in">prefix</span>(i - <span class="hljs-number">1</span>);<br>        ans = <span class="hljs-built_in">max</span>(ans + a[up], ans * b[up]);<br>        <span class="hljs-comment">// cout &lt;&lt; &quot;ans: &quot; &lt;&lt; ans &lt;&lt; &quot;\n&quot;;</span><br>        i = up + <span class="hljs-number">1</span>;<br>      &#125;<br>      cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="c---row-and-column-order构造">9.<strong>C - Row and ColumnOrder</strong>(构造)</h2><p>https://atcoder.jp/contests/arc181/tasks/arc181_c构造</p><h3 id="法一">法一</h3><p>一种简单的做法是，将<span class="math inline">\(S_j:=S_i\)</span>然后在加一个1。这样就能保证满足行，对于列，若我们按Q从后往前加，就能保证，前面的包含在后面的，且后面的1更多，因此也满足。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin &gt;&gt; n;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">q</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; p[i];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; q[i];<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ans</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = n; i &lt;= n; ++i, --j) &#123;<br>    ans[p[i]] = ans[p[i - <span class="hljs-number">1</span>]];<br>    ans[p[i]][q[j]] = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>      cout &lt;&lt; ans[i][j];<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="法二">法二</h3><p>我们递归的做，先将<spanclass="math inline">\(P_1\)</span>全填0，<spanclass="math inline">\(Q_n\)</span>全填1，然后删除这一行和列。</p><p>这样做，对于行，后填的填的1更多，且前面的含于后面。</p><p>对于列，同理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin &gt;&gt; n;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">q</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; p[i];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; q[i];<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ans</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>));<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">auto</span> dfs = [&amp;](<span class="hljs-keyword">auto</span>&amp; self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;<br>    <span class="hljs-keyword">if</span> (x &gt; n) <span class="hljs-keyword">return</span>;<br>    c[p[x]] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (c[i]) <span class="hljs-keyword">continue</span>;<br>      ans[i][q[n + <span class="hljs-number">1</span> - x]] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">self</span>(self, x + <span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>      cout &lt;&lt; ans[i][j];<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="d.-connect-the-dots并查集dp">10.D. Connect theDots(并查集+dp)</h2><p>https://codeforces.com/contest/2020/problem/D</p><p>并查集+dp</p><p>注意到d很小，因此可以枚举d，考虑将d当做一个常数。</p><p>对于固定的d，如果我们知道每一个点所能连接的最远的点。就可以轻松解决。</p><p>我们设<code>f[i][j]</code>为<spanclass="math inline">\(d=j\)</span>时，i的最远点。有状态转移方程 <spanclass="math display">\[f_{i,j}=\max(f_{i,j},(f_{i,j}\geq i+j)f_{i+1,j})\]</span></p><p><span class="math display">\[f_{i+j,j}=\max(f_{i+j,j},f_{i,j})\]</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, m;<br>  cin &gt;&gt; n &gt;&gt; m;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) pre[i] = i;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>      f[j][i] = j;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>    <span class="hljs-type">int</span> a, d, k;<br>    cin &gt;&gt; a &gt;&gt; d &gt;&gt; k;<br>    f[a][d] = <span class="hljs-built_in">max</span>(f[a][d], a + k * d);<br>  &#125;<br>  <span class="hljs-comment">//  d: 1~10</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (f[j - i][i] &gt;= j) &#123;<br>        f[j - i][i] = <span class="hljs-built_in">max</span>(f[j - i][i], f[j][i]);<br>        f[j][i] = f[j - i][i];<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= <span class="hljs-number">1</span>; --j) &#123;<br>      <span class="hljs-built_in">merge</span>(j, f[j][i]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">root</span>(i) == i) ans++;<br>  &#125;<br>  cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="b---improve-inversions贪心">11.<strong>B - ImproveInversions</strong>(贪心)</h2><p>https://atcoder.jp/contests/arc180/tasks/arc180_b</p><p>对于<spanclass="math inline">\(i\)</span>来说，我们在后面找比他小的然后从大到小交换是最好的。</p><p>那么我们从小到大枚举<spanclass="math inline">\(i\)</span>，然后从大到小交换，因为前面交换的都比<spanclass="math inline">\(i\)</span>小，那么不会影响<spanclass="math inline">\(i\)</span>的交换次数。</p><p>因此可以达到 <span class="math display">\[\sum_{i=1}^{n}\sum_{j=i+k}^{n}[a_j&lt;a_i]\]</span> 并且可以证明这是最大的。因为假设我们交换一次，<spanclass="math inline">\(x,y(x&lt;y)\)</span> ，那么，对于<spanclass="math inline">\(l\leq x-k\)</span>和<spanclass="math inline">\(l&gt;y-k\)</span>不会有影响。但对于<spanclass="math inline">\(x-k&lt;l\leq y-k\)</span>若<spanclass="math inline">\(l=x\)</span>，则一定减少一次，否则，至少可以保证不会变多。</p><p>因此这就是最大值。</p><h2 id="f---tree-degree-optimization贪心-prufer-序列">12.<strong>F -Tree Degree Optimization</strong>(贪心 prufer 序列)</h2><p>https://oi-wiki.org/graph/prufer/</p><h2 id="g---atcoder-tourdp最短路">13.<strong>G - AtCoderTour</strong>(DP/最短路)</h2><p>https://atcoder.jp/contests/abc358/tasks/abc358_g</p><p>容易想到它一定会走到一个终点并一直停在那里。</p><h3 id="法一-1">法一</h3><p>可以枚举终点<code>(i,j)</code>。只连接权值小于终点的点。定义权值为<code>a[i][j]-a[x][y]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ll a[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];<br>ll n, m, k, d[<span class="hljs-number">3000</span>];<br>vector&lt;pll&gt; g[<span class="hljs-number">3000</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">to_i</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> (x - <span class="hljs-number">1</span>) * m + y; &#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">0</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt; <span class="hljs-number">0</span> &amp;&amp; y &lt;= m; &#125;<br><br>bitset&lt;3000&gt; vis;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dij</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  vis = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2500</span>; ++i) d[i] = linf;<br>  d[x] = <span class="hljs-number">0</span>;<br>  priority_queue&lt;pll, vector&lt;pll&gt;, greater&lt;pll&gt;&gt; q;<br>  q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, x&#125;);<br>  <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>    <span class="hljs-keyword">auto</span> [_, id] = q.<span class="hljs-built_in">top</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span> (vis[id]) <span class="hljs-keyword">continue</span>;<br>    vis[id] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [y, z] : g[id]) &#123;<br>      <span class="hljs-keyword">if</span> (d[y] &gt; d[id] + z) &#123;<br>        d[y] = d[id] + z;<br>        q.<span class="hljs-built_in">push</span>(&#123;d[y], y&#125;);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>  <span class="hljs-type">int</span> si, sj;<br>  cin &gt;&gt; si &gt;&gt; sj;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>      cin &gt;&gt; a[i][j];<br>    &#125;<br>  &#125;<br>  ll ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (a[i][j] &lt; a[si][sj]) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ii = <span class="hljs-number">1</span>; ii &lt;= n; ++ii) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> jj = <span class="hljs-number">1</span>; jj &lt;= m; ++jj) &#123;<br>          g[<span class="hljs-built_in">to_i</span>(ii, jj)].<span class="hljs-built_in">clear</span>();<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ii = <span class="hljs-number">1</span>; ii &lt;= n; ++ii) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> jj = <span class="hljs-number">1</span>; jj &lt;= m; ++jj) &#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(ii + <span class="hljs-number">1</span>, jj)) &#123;<br>            <span class="hljs-keyword">if</span> (a[ii + <span class="hljs-number">1</span>][jj] &lt;= a[i][j]) g[<span class="hljs-built_in">to_i</span>(ii, jj)].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-built_in">to_i</span>(ii + <span class="hljs-number">1</span>, jj), a[i][j] - a[ii + <span class="hljs-number">1</span>][jj]&#125;);<br>            <span class="hljs-keyword">if</span> (a[ii][jj] &lt;= a[i][j]) g[<span class="hljs-built_in">to_i</span>(ii + <span class="hljs-number">1</span>, jj)].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-built_in">to_i</span>(ii, jj), a[i][j] - a[ii][jj]&#125;);<br>          &#125;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(ii, jj + <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">if</span> (a[ii][jj + <span class="hljs-number">1</span>] &lt;= a[i][j]) g[<span class="hljs-built_in">to_i</span>(ii, jj)].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-built_in">to_i</span>(ii, jj + <span class="hljs-number">1</span>), a[i][j] - a[ii][jj + <span class="hljs-number">1</span>]&#125;);<br>            <span class="hljs-keyword">if</span> (a[ii][jj] &lt;= a[i][j]) g[<span class="hljs-built_in">to_i</span>(ii, jj + <span class="hljs-number">1</span>)].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-built_in">to_i</span>(ii, jj), a[i][j] - a[ii][jj]&#125;);<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-built_in">dij</span>(<span class="hljs-built_in">to_i</span>(si, sj));<br>      <span class="hljs-comment">// cout &lt;&lt; &quot;end:&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span><br>      <span class="hljs-comment">// cout &lt;&lt; &quot;dis:&quot; &lt;&lt; d[to_i(i, j)] &lt;&lt; endl;</span><br>      ans = <span class="hljs-built_in">max</span>(ans, k * a[i][j] - d[<span class="hljs-built_in">to_i</span>(i, j)]);<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="法二-1">法二</h3><p>枚举走到终点的步数。利用dp找到指定步数下最大权值。可利用滚动数组优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>  <span class="hljs-type">int</span> si, sj;<br>  cin &gt;&gt; si &gt;&gt; sj;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>      cin &gt;&gt; a[i][j];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>      f[<span class="hljs-number">0</span>][i][j] = f[<span class="hljs-number">1</span>][i][j] = -linf;<br>    &#125;<br>  &#125;<br>  f[<span class="hljs-number">0</span>][si][sj] = <span class="hljs-number">0</span>;<br>  ll ans = k * a[si][sj];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt;= <span class="hljs-built_in">min</span>(k, <span class="hljs-number">1ll</span> * n * m); ++x) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">0</span>; t &lt; <span class="hljs-number">4</span>; ++t) &#123;<br>          <span class="hljs-type">int</span> cx = i + dx[t], cy = j + dy[t];<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(cx, cy)) f[x &amp; <span class="hljs-number">1</span>][i][j] = <span class="hljs-built_in">max</span>(f[(x - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">1</span>][cx][cy] + a[i][j], f[x &amp; <span class="hljs-number">1</span>][i][j]);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>        ans = <span class="hljs-built_in">max</span>(ans, f[x &amp; <span class="hljs-number">1</span>][i][j] + (k - x) * a[i][j]);<br>      &#125;<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="help-is-needed-for-dexter数学">14.Help is needed forDexter（数学）</h2><p>https://www.luogu.com.cn/problem/UVA11384</p><p>显然重复的元素越多越好。</p><p>注意到一种较优的做法是 <span class="math display">\[f_n=f_{\left\lfloor\frac{n}{2} \right\rfloor}+1\]</span> 先在来证明这是最优的。显然有<spanclass="math inline">\(f_n\)</span>是不减少的。</p><p>有<spanclass="math inline">\(f_n=\left\lfloor\log_2{n}\right\rfloor+1\)</span></p><p>若这不是最优的，则存在最小的<spanclass="math inline">\(m\)</span>使得 <span class="math display">\[f_m\leq \left\lfloor\log_2{m}\right\rfloor\]</span> 那么 <span class="math display">\[f_{m-1}=\left\lfloor\log_2{(m-1)}\right\rfloor+1\]</span> 而<span class="math inline">\(f_m\geq f_{m-1}\)</span>，故<span class="math display">\[m=2^k\]</span> 因此我们可以进行<spanclass="math inline">\(k\)</span>次操作让，<spanclass="math inline">\(2^k\)</span>个元素变成0，不妨设第<spanclass="math inline">\(i\)</span>次操作减去<spanclass="math inline">\(a_i\)</span>。</p><p>设<span class="math inline">\(S\)</span>为<spanclass="math inline">\(\{1,2,\cdots,k\}\)</span>的非空子集。那么就有对于<spanclass="math inline">\(1\leq x \leq 2^k\)</span> 存在一个<spanclass="math inline">\(S\)</span> 使得<spanclass="math inline">\(\sum_{i\in S} a_i=x\)</span>，但是只有<spanclass="math inline">\(2^k-1\)</span>个非空子集。不可能形成<spanclass="math inline">\(2^k\)</span>个元素。</p><p>故上式就是最优解。</p><h2 id="colored-cubes枚举">15.Colored Cubes（枚举）</h2><p>https://www.luogu.com.cn/problem/UVA1352</p><p>数据很小，考虑直接枚举。难点在于写代码。</p><p>可以先打表出一个正方体的所有情况，枚举每一个正方体的情况，第一个可以按照默认位置。然后记录每一面的各个颜色出现次数，保留最多的即可。</p><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REP(i, n) for (int i = 1; i &lt;= (n); ++i)</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pii;<br><span class="hljs-keyword">typedef</span> pair&lt;ll, ll&gt; pll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br><span class="hljs-comment">// using i128=__int128_t;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">9</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> iinf = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">const</span> ll linf = <span class="hljs-number">1e18</span>;<br><br><span class="hljs-type">int</span> pose[<span class="hljs-number">25</span>][<span class="hljs-number">7</span>] = &#123;<br>    &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>&#125;,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;<br>    vector&lt;array&lt;string, 10&gt;&gt; <span class="hljs-built_in">col</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">REP</span>(i, n) <span class="hljs-built_in">REP</span>(j, <span class="hljs-number">6</span>) cin &gt;&gt; col[i][j];<br>    <span class="hljs-type">int</span> ans = iinf;<br>    <span class="hljs-type">int</span> p[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">auto</span> count = [&amp;]() -&gt; <span class="hljs-type">int</span> &#123;<br>      map&lt;string, <span class="hljs-type">int</span>&gt; cnt[<span class="hljs-number">7</span>];<br>      <span class="hljs-built_in">REP</span>(i, <span class="hljs-number">6</span>) cnt[i][col[<span class="hljs-number">1</span>][i]]++;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-built_in">REP</span>(j, <span class="hljs-number">6</span>) cnt[j][col[i][pose[p[i]][j]]]++;<br>      &#125;<br>      <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>      <span class="hljs-built_in">REP</span>(i, <span class="hljs-number">6</span>) &#123;<br>        <span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = cnt[i].<span class="hljs-built_in">begin</span>(); it != cnt[i].<span class="hljs-built_in">end</span>(); ++it) mx = <span class="hljs-built_in">max</span>(mx, it-&gt;second);<br>        res += n - mx;<br>      &#125;<br>      <span class="hljs-keyword">return</span> res;<br>    &#125;;<br>    function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> id) -&gt; <span class="hljs-type">void</span> &#123;<br>      <span class="hljs-keyword">if</span> (id &gt; n) <span class="hljs-keyword">return</span> ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">count</span>()), <span class="hljs-built_in">void</span>();<br>      <span class="hljs-built_in">REP</span>(i, <span class="hljs-number">24</span>) &#123;<br>        p[id] = i;<br>        <span class="hljs-built_in">dfs</span>(id + <span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">2</span>);<br>    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">STDIO</span><span class="hljs-params">()</span> </span>&#123;<br>  ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">STDIO</span>();<br>  <span class="hljs-type">int</span> _ = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// cin&gt;&gt;_;</span><br>  <span class="hljs-keyword">while</span> (_--) <span class="hljs-built_in">solve</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="even-parity枚举">16.Even Parity（枚举）</h2><p>https://www.luogu.com.cn/problem/UVA11464</p><p>第一行一旦确定，所有的都确定了。枚举第一行的所有情形。检查是否满足条件即可。</p><p>难点还是写代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REP(i, n) for (int i = 1; i &lt;= (n); ++i)</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pii;<br><span class="hljs-keyword">typedef</span> pair&lt;ll, ll&gt; pll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br><span class="hljs-comment">// using i128=__int128_t;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">9</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> iinf = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">const</span> ll linf = <span class="hljs-number">1e18</span>;<br><span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin &gt;&gt; n;<br>  <span class="hljs-keyword">auto</span> check = [&amp;](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123; <span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">0</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt; <span class="hljs-number">0</span> &amp;&amp; y &lt;= n; &#125;;<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">a</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>));<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">c</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>));<br>  <span class="hljs-built_in">REP</span>(i, n) <span class="hljs-built_in">REP</span>(j, n) cin &gt;&gt; a[i][j];<br>  <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>, mi = iinf;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1ll</span> &lt;&lt; n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) b[j + <span class="hljs-number">1</span>] = i &gt;&gt; j &amp; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">bool</span> ok = <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n &amp;&amp; ok; ++j) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n &amp;&amp; ok; ++k) &#123;<br>        <span class="hljs-keyword">if</span> (b[k] == <span class="hljs-number">0</span> &amp;&amp; a[j][k] == <span class="hljs-number">1</span>) ok = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (b[k] == <span class="hljs-number">1</span> &amp;&amp; a[j][k] == <span class="hljs-number">0</span>) cnt++, c[j][k] = b[k];<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; ++k) &#123;<br>        <span class="hljs-type">int</span> C = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt; <span class="hljs-number">3</span>; ++l) &#123;<br>          <span class="hljs-type">int</span> cx = j + dx[l], cy = k + dy[l];<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(cx, cy) &amp;&amp; c[cx][cy]) C++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (C &amp; <span class="hljs-number">1</span>) &#123;<br>          b[k] = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          b[k] = <span class="hljs-number">0</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ok) mi = <span class="hljs-built_in">min</span>(mi, cnt);<br>    c = a;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (mi &lt; iinf) ans = mi;<br>  cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">STDIO</span><span class="hljs-params">()</span> </span>&#123;<br>  ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">STDIO</span>();<br>  <span class="hljs-type">int</span> _ = <span class="hljs-number">1</span>;<br>  cin &gt;&gt; _;<br>  <span class="hljs-built_in">REP</span>(i, _) cout &lt;&lt; <span class="hljs-string">&quot;Case &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>, <span class="hljs-built_in">solve</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="image-is-everything枚举">17.Image Is Everything(枚举)</h2><p>https://www.luogu.com.cn/problem/UVA1030</p><p>我们将一定没有的位置标记出来，即可算出答案。有以下两种情况。</p><ol type="1"><li>视图有<code>.</code>。</li><li>几个视图相互矛盾。</li></ol><p>难点依旧是写代码。具体实现看代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REP(i, n) for (int i = 1; i &lt;= (n); ++i)</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pii;<br><span class="hljs-keyword">typedef</span> pair&lt;ll, ll&gt; pll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br><span class="hljs-comment">// using i128=__int128_t;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">9</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> iinf = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">const</span> ll linf = <span class="hljs-number">1e18</span>;<br><br><span class="hljs-type">char</span> s[<span class="hljs-number">10</span>][<span class="hljs-number">15</span>][<span class="hljs-number">15</span>], h[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">T</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span>&amp; y, <span class="hljs-type">int</span>&amp; z)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x = l, y = k, z = j, <span class="hljs-built_in">void</span>();<br>  <span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> x = n + <span class="hljs-number">1</span> - k, y = l, z = j, <span class="hljs-built_in">void</span>();<br>  <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> x = n + <span class="hljs-number">1</span> - l, y = n + <span class="hljs-number">1</span> - k, z = j, <span class="hljs-built_in">void</span>();<br>  <span class="hljs-keyword">if</span> (i == <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> x = k, y = n + <span class="hljs-number">1</span> - l, z = j, <span class="hljs-built_in">void</span>();<br>  <span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span> x = n + <span class="hljs-number">1</span> - j, y = k, z = l, <span class="hljs-built_in">void</span>();<br>  <span class="hljs-keyword">if</span> (i == <span class="hljs-number">6</span>) <span class="hljs-keyword">return</span> x = j, y = k, z = n + <span class="hljs-number">1</span> - l, <span class="hljs-built_in">void</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;<br>    <span class="hljs-built_in">REP</span>(i, n) <span class="hljs-built_in">REP</span>(j, <span class="hljs-number">6</span>) <span class="hljs-built_in">REP</span>(k, n) cin &gt;&gt; s[j][i][k];<br>    <span class="hljs-built_in">REP</span>(i, n) <span class="hljs-built_in">REP</span>(j, n) <span class="hljs-built_in">REP</span>(k, n) h[i][j][k] = <span class="hljs-string">&#x27;?&#x27;</span>;<br>    <span class="hljs-built_in">REP</span>(i, <span class="hljs-number">6</span>) <span class="hljs-built_in">REP</span>(j, n) <span class="hljs-built_in">REP</span>(k, n) <span class="hljs-keyword">if</span> (s[i][j][k] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>      <span class="hljs-built_in">REP</span>(l, n) &#123;<br>        <span class="hljs-type">int</span> x, y, z;<br>        <span class="hljs-built_in">T</span>(i, j, k, l, x, y, z);<br>        h[x][y][z] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-type">bool</span> ok = <span class="hljs-literal">true</span>;<br>      <span class="hljs-built_in">REP</span>(i, <span class="hljs-number">6</span>) <span class="hljs-built_in">REP</span>(j, n) <span class="hljs-built_in">REP</span>(k, n) <span class="hljs-keyword">if</span> (s[i][j][k] != <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>        <span class="hljs-built_in">REP</span>(l, n) &#123;<br>          <span class="hljs-type">int</span> x, y, z;<br>          <span class="hljs-built_in">T</span>(i, j, k, l, x, y, z);<br>          <span class="hljs-keyword">if</span> (h[x][y][z] == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>          <span class="hljs-keyword">if</span> (h[x][y][z] == <span class="hljs-string">&#x27;?&#x27;</span>) &#123;<br>            h[x][y][z] = s[i][j][k];<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>          <span class="hljs-keyword">if</span> (h[x][y][z] == s[i][j][k]) <span class="hljs-keyword">break</span>;<br>          h[x][y][z] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>          ok = <span class="hljs-literal">false</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (ok) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">REP</span>(i, n) <span class="hljs-built_in">REP</span>(j, n) <span class="hljs-built_in">REP</span>(k, n) ans += (h[i][j][k] != <span class="hljs-string">&#x27;.&#x27;</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Maximum weight: &quot;</span> &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot; gram(s)\n&quot;</span>;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">STDIO</span><span class="hljs-params">()</span> </span>&#123;<br>  ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">STDIO</span>();<br>  <span class="hljs-type">int</span> _ = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// cin&gt;&gt;_;</span><br>  <span class="hljs-keyword">while</span> (_--) <span class="hljs-built_in">solve</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ACM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5thCombinatorics7</title>
    <link href="/2024/10/01/5thCombinatorics7/"/>
    <url>/2024/10/01/5thCombinatorics7/</url>
    
    <content type="html"><![CDATA[<h1 id="递推关系和生成函数">递推关系和生成函数</h1><h2 id="section">1</h2><blockquote><figure><img src="/images/image-20240909140350501.png"alt="image-20240909140350501" /><figcaption aria-hidden="true">image-20240909140350501</figcaption></figure></blockquote><h3 id="d">d</h3><p><span class="math display">\[\begin{aligned}\sum_{i=0}^{n} f_i^2&amp;=f_0^2+\sum_{i=1}^{n}f_i^2\\&amp;=f_0f_1+\left(f_1(f_2-f_0)+f_2(f_3-f_1)+\cdots+f_n(f_{n+1}-f_{n-1})\right)\\&amp;=f_nf_{n+1}\end{aligned}\]</span></p><h2 id="section-1">2</h2><blockquote><figure><img src="/images/image-20240909140828646.png"alt="image-20240909140828646" /><figcaption aria-hidden="true">image-20240909140828646</figcaption></figure></blockquote><p>容易想到证明<spanclass="math inline">\(f_n\)</span>与上式差值绝对值小于<spanclass="math inline">\(\frac{1}{2}\)</span> <span class="math display">\[\begin{aligned}\left |f_n-\frac{1}{\sqrt{5}} {\left( \frac{1+\sqrt{5}}{2} \right)^n}\right|&amp;=\left|\frac{1}{\sqrt{5}} {\left( \frac{1-\sqrt{5}}{2}\right)}^n \right| \\&amp;=\frac{1}{\sqrt{5}}\left(\frac{2}{\left(1+\sqrt{5} \right)}\right)^n\\&amp;&lt;\frac{1}{\sqrt{5}}\\&amp;&lt;\frac{1}{2}\end{aligned}\]</span></p><h2 id="section-2">3</h2><blockquote><figure><img src="/images/image-20240909141704032.png"alt="image-20240909141704032" /><figcaption aria-hidden="true">image-20240909141704032</figcaption></figure></blockquote><h3 id="b">b</h3><p><span class="math display">\[f_n=3f_{n-3}+2f_{n-4}\equiv 2f_{n-4} \mod{3}\]</span></p><p>因此 <span class="math display">\[3|f_n\iff 3|f_{n-4}\]</span></p><h3 id="c">c</h3><p>我们对斐波拉契数列 取模有 <span class="math display">\[0,1,1,2,3,1,0,1,\cdots\]</span> 发现其以<span class="math inline">\(6\)</span>为周期循环。</p><h2 id="section-3">6</h2><blockquote><figure><img src="/images/image-20240910155854537.png"alt="image-20240910155854537" /><figcaption aria-hidden="true">image-20240910155854537</figcaption></figure></blockquote><p>我们令 <span class="math display">\[f_n=a_xf_{n-x}+b_xf_{n-x-1}\]</span> 显然有 <span class="math display">\[b_n=a_{n-1}\]</span> 且 <span class="math display">\[a_n=a_{n-1}+b_{n-1}=a_{n-1}+a_{n-2}\Rightarrow b_n=b_{n-1}+b_{n-2}\]</span></p><p>又<span class="math inline">\(b_0=0,b_1=1\)</span>故<spanclass="math inline">\(b\)</span>是斐波拉契数列。</p><p>那么有 <span class="math display">\[f_n=f_{x+1}f_{n-x}+f_xf_{n-x-1}\]</span> 设<spanclass="math inline">\(n=km\)</span>，用数学归纳法即可。</p><h2 id="section-4">7</h2><blockquote><figure><img src="/images/image-20240910160533931.png"alt="image-20240910160533931" /><figcaption aria-hidden="true">image-20240910160533931</figcaption></figure></blockquote><p>设<span class="math inline">\(n=km+r\)</span> ，</p><p>那么有 <span class="math display">\[f_n=f_{r+1}f_{km}+f_rf_{km-1}\]</span> 注意到 <span class="math display">\[\gcd(f_n,f_{n+1}) =1\]</span> 我们有 <span class="math display">\[f_{km-1}=f_mf_{(k-1)m}+f_{m-1}f_{(k-1)m-1}\]</span></p><p>从而有 <span class="math display">\[\gcd(f_{km-1},f_m)=\gcd(f_m,f_{m-1})=1\]</span> 故 <span class="math display">\[\gcd(f_n,f_m)=\gcd(f_m,f_r)\]</span> 然后令n=m，m=r。类比欧几里得算法。可得 <spanclass="math display">\[\gcd(f_n,f_m)=f_{\gcd(n,m)}\]</span></p><h2 id="section-5">9</h2><blockquote><figure><img src="/images/image-20240910165450019.png"alt="image-20240910165450019" /><figcaption aria-hidden="true">image-20240910165450019</figcaption></figure></blockquote><p>有 <span class="math display">\[h_n=2(h_{n-1}+h_{n-2})\]</span> 特征方程<span class="math inline">\(x^2-2x-2=0\)</span>的根为<span class="math display">\[x=1\pm\sqrt{3}\]</span> 初值为<span class="math inline">\(h_0=1,h_1=3\)</span></p><p>带入得 <span class="math display">\[\begin{cases}c_1+c_2=1\\c_1(1+\sqrt{3})+c_2(1-\sqrt{3})=3\end{cases}\]</span> 解得 <span class="math display">\[c_1=\frac{3+2\sqrt{3}}{6}(1+\sqrt{3})^n+\frac{3-2\sqrt{3}}{6}(1-\sqrt{3})^n\]</span></p><h2 id="section-6">15</h2><blockquote><figure><img src="/images/image-20240910170155353.png"alt="image-20240910170155353" /><figcaption aria-hidden="true">image-20240910170155353</figcaption></figure></blockquote><p>有 <span class="math display">\[\frac{1}{1-x}=\sum_{n=0}^{\infty}x^n\]</span> 同时微分并乘<span class="math inline">\(x\)</span> <spanclass="math display">\[\frac{x}{(1-x)^2}=\sum_{n=0}^{\infty}nx^n\]</span> 同时微分并乘<span class="math inline">\(x\)</span> <spanclass="math display">\[\frac{x-x^3}{(1-x)^4}=\sum_{n=0}^{\infty}n^2x^n\]</span> 同时微分并乘<span class="math inline">\(x\)</span> <spanclass="math display">\[\frac{x^3+4x^2+x}{(1-x)^4}=\sum_{n=0}^{\infty}n^3x^n\]</span> 或者由 <span class="math display">\[n^3 = 6 \binom{n}{3} + 6 \binom{n}{2} + \binom{n}{1}\]</span> 得 <span class="math display">\[\begin{aligned}g(x)&amp;=\sum_{n=0}^{\infty}6\binom{n}{3}x^n+\sum_{n=0}^{\infty}6\binom{n}{2}x^n+\sum_{n=0}^{\infty} \binom{n}{1}x^n\\&amp;=6x^3\sum_{n=0}^{\infty}\binom{n+3}{n}x^n+6x^2\sum_{n=0}^{\infty}\binom{n+2}{n}x^n+x\sum_{n=0}^{\infty}\binom{n+1}{n}x^n\\&amp;=\frac{6x^3}{(1-x)^4}+\frac{6x^2}{(1-x)^3}+\frac{x}{(1-x)^2}\\&amp;=\frac{x^3+4x^2+x}{(1-x)^4}\end{aligned}\]</span></p><h2 id="section-7">21</h2><blockquote><figure><img src="/images/image-20240911135029474.png"alt="image-20240911135029474" /><figcaption aria-hidden="true">image-20240911135029474</figcaption></figure></blockquote><p>设该<span class="math inline">\(n+2\)</span>边形其中一个顶点为<spanclass="math inline">\(v\)</span>，我们连接其左右两个顶点后形成一个<spanclass="math inline">\(n+1\)</span>边形。然后设其连出去的<spanclass="math inline">\(n-1\)</span>条对角线分别产生<spanclass="math inline">\(k_i\)</span>个交点。那么将新产生<spanclass="math inline">\(k_i+1\)</span>个区域。因此答案为 <spanclass="math display">\[h_n=h_{n-1}+1+\sum_{i=1}^{n-1}(k_i+1)=h_{n-1}+n+\sum_{i=1}^{n-1}k_i\]</span> 而事实上<span class="math inline">\(k_i\)</span>的和就是<spanclass="math inline">\(n+2\)</span>边形的对角线产生的非顶点的交点数与<spanclass="math inline">\(n+1\)</span>边形的差。</p><p><strong>引理</strong>：而对于一个<spanclass="math inline">\(n\)</span>边形不考虑共点和顶点的情况下，将产生<spanclass="math inline">\(\binom{n}{4}\)</span>的交点。</p><p><strong>证明：</strong>对于四个顶点，我们连完对角线将产生一个交点，而任意一个交点，将对应四个顶点。因此交点数和从<spanclass="math inline">\(n\)</span>个顶点选出4个点是一一对应的。证毕。</p><p>故上式等于 <span class="math display">\[\begin{aligned}h_n&amp;=h_{n-1}+n+\sum_{i=1}^{n-1}k_i\\&amp;=h_{n-1}+\binom{n+2}{4}-\binom{n+1}{4}+n\\&amp;=h_{n-1}+\binom{n+1}{3}+n\end{aligned}\]</span> 有 <span class="math display">\[\begin{aligned}(1-x)g(x)&amp;=h_0+\sum_{n=1}^{\infty}\left(\binom{n+1}{3}+n\right)x^{n}\\&amp;=\sum_{n=1}^{\infty}\binom{n+1}{3}x^n+\sum_{n=1}^{\infty}nx^n\\&amp;=x^2\sum_{n=0}^{\infty}\binom{n+3}{3}x^n+\sum_{n=0}^{\infty} nx^n\\&amp;=\frac{x^2}{(1-x)^4}+\frac{x}{(1-x)^2}\\\end{aligned}\]</span> 从而 <span class="math display">\[\begin{aligned}g(x)&amp;=\frac{x^2}{(1-x)^5}+\frac{x}{(1-x)^3}\\&amp;=x^2\sum_{n=0}^{\infty}\binom{n+4}{n}x^n+x\sum_{n=0}^{\infty}\binom{n+2}{n}x^n\\&amp;=\sum_{n=0}^{\infty}\binom{n+2}{4}x^n+\sum_{n=0}^{\infty}\binom{n+1}{2}x^n\\&amp;=\sum_{n=0}^{\infty}\left(\binom{n+2}{4}+\binom{n+1}{2} \right)x^n\end{aligned}\]</span> 综上 <span class="math display">\[h_n=\binom{n+2}{4}+\binom{n+1}{2}\]</span> 或者考虑迭代法</p><h2 id="section-8">25</h2><blockquote><figure><img src="/images/image-20240914213455922.png"alt="image-20240914213455922" /><figcaption aria-hidden="true">image-20240914213455922</figcaption></figure></blockquote><p>使用生成函数： <span class="math display">\[\begin{aligned}g(x)&amp;=\left(\sum_{n=0}^{\infty}\frac{x^n}{n!}\right)^2\left(1+\frac{x^2}{2!}+\cdots\right)\left(x+\frac{x^3}{3!}+\cdots \right)\\&amp;=e^{2x}\left(\frac{e^x+e^{-x}}{2} \right) \left(\frac{e^x-e^{-x}}{2} \right)\\&amp;=\frac{e^{4x}-1}{4}\\&amp;=\frac{1}{4}\sum_{n=0}^{\infty} 4^{n} \frac{x^n}{n!}-\frac{1}{4}\\&amp;=\sum_{n=1}^{\infty} 4^{n-1} \frac{x^n}{n!}\end{aligned}\]</span> 故 <span class="math display">\[h_n=4^{n-1}(n\geq 1)\]</span> 特别地：<span class="math inline">\(h_0=1\)</span></p><h2 id="section-9">29</h2><blockquote><figure><img src="/images/image-20240920143718421.png"alt="image-20240920143718421" /><figcaption aria-hidden="true">image-20240920143718421</figcaption></figure></blockquote><p>设<span class="math inline">\(a_n\)</span>为<spanclass="math inline">\(1,3\)</span>均出现奇数次时的数，且<spanclass="math inline">\(b_n\)</span>为一奇一偶。</p><p>那么有 <span class="math display">\[\begin{cases}a_n=3a_{n-1}+2b_{n-1}\\b_n=3b_{n-1}+a_{n-1}+h_{n-1}\\h_n=3h_{n-1}+2b_{n-1}\\a_n+2b_n+h_n=5^n\end{cases}\]</span> 消元可得到<span class="math inline">\(h_n\)</span>的递推式<span class="math display">\[h_n-4h_{n-1}+3h_{n-2}=2\cdot5^{n-2}\]</span> 其齐次递推式的特征方程为 <span class="math display">\[x^2-4x+3=0\]</span> 从而求出解 <span class="math display">\[H_n=c_13^n+c_2\]</span> 下面求一个特解，设<spanclass="math inline">\(h_n=p5^n\)</span>，解得<spanclass="math inline">\(p=\frac{1}{4}\)</span>。</p><p>那么 <span class="math display">\[h_n=c_13^n+c_2+\frac{5^n}{4}\]</span> 带入<span class="math inline">\(h_0,h_1\)</span>得 <spanclass="math display">\[h_n=\frac{2\cdot 3^n+1+5^n}{4}\]</span> 或者根据递推式，利用生成函数： <span class="math display">\[\begin{aligned}(1-4x+3x^2)g(x)&amp;=1-x+\sum_{n=2}^{\infty}2\cdot5^{n-2}x^n\\&amp;=1-x+2x^2\sum_{n=0}^{\infty}(5x)^n\\&amp;=1-x+\frac{2x^2}{1-5x}\end{aligned}\]</span> 那么 <span class="math display">\[\begin{aligned}g(x)&amp;=\frac{1-x}{1-4x+3x^2}+\frac{2x^2}{(1-5x)(1-4x+3x^2)}\\&amp;=\frac{1}{1-3x}+\frac{\frac{1}{4}}{1-5x}-\frac{\frac{1}{2}}{1-3x}+\frac{\frac{1}{4}}{1-x}\\&amp;=\frac{1}{2}\sum_{n=0}^{\infty}3^nx^n+\frac{1}{4}\sum_{n=0}^{\infty}5^nx^n+\frac{1}{4}\sum_{n=0}^{\infty}x^n\\&amp;=\sum_{n=0}^{\infty}\left(\frac{5^n+2\cdot3^n+1}{4} \right)x^n\end{aligned}\]</span> 故 <span class="math display">\[h_n=\frac{5^n+2\cdot3^n+1}{4}\]</span></p><h2 id="section-10">37</h2><blockquote><figure><img src="/images/image-20240924154940086.png"alt="image-20240924154940086" /><figcaption aria-hidden="true">image-20240924154940086</figcaption></figure></blockquote><p>为了计算<spanclass="math inline">\(a_n\)</span>我们不妨将其分成以<spanclass="math inline">\(22\)</span>开头的和其他，若以<spanclass="math inline">\(22\)</span>开头显然有<spanclass="math inline">\(a_{n-2}\)</span> 种，否则我们再将<spanclass="math inline">\(a_{n-1}\)</span>分成三类，开头为<spanclass="math inline">\(0,1,2\)</span></p><p>设其分别有<span class="math inline">\(x,y,z\)</span>种。</p><p>那么有 <span class="math display">\[a_n=(y+z)+(x+z)+(x+y)+a_{n-2}=2a_{n-1}+a_{n-2}\]</span></p><h2 id="section-11">41</h2><blockquote><figure><img src="/images/image-20240924154950797.png"alt="image-20240924154950797" /><figcaption aria-hidden="true">image-20240924154950797</figcaption></figure></blockquote><p>我们不妨对这<spanclass="math inline">\(2n\)</span>个点编号，若我们先连接<spanclass="math inline">\(1,x\)</span>，显然<spanclass="math inline">\(2|x\)</span>，且满足递推式 <spanclass="math display">\[h_n=\sum_{k=1}^{n}h_{k-1}h_{n-k}\]</span> 为卡特兰序列。</p><p>故 <span class="math display">\[h_n=\frac{1}{n+1} \binom{2n}{n}\]</span></p><h2 id="section-12">49</h2><blockquote><figure><img src="/images/image-20240929111735871.png"alt="image-20240929111735871" /><figcaption aria-hidden="true">image-20240929111735871</figcaption></figure></blockquote><p><strong>公式似乎有错</strong>，应该是 <span class="math display">\[(x+y)(x+qy)\cdots(x+q^{m-1}y)=\sum_{k=0}^{n}q^{\binom{k}{2}}\binom{n}{k}_qx^{n-k}y^k\]</span></p><p>注意到： <span class="math display">\[\binom{n}{k}_q=\prod_{i=1}^{k}\frac{1-q^{n-k+i}}{1-q^i}\]</span> 因此： <span class="math display">\[\binom{n}{k}_q=\frac{1-q^n}{1-q^{n-k}}\binom{n-1}{k}_q\\\binom{n}{k}_q=\frac{1-q^n}{1-q^k}\binom{n-1}{k-1}_q\]</span> 故 <span class="math display">\[\begin{aligned}q^k\binom{n}{k}_q+\binom{n}{k-1}_q&amp;=q^k\frac{1-q^{n+1-k}}{1-q^{n+1}}\binom{n+1}{k}+\frac{1-q^k}{1-q^{n+1}}\binom{n+1}{k}\\&amp;=\left(\frac{q^k-q^{n+1}+1-q^{k}}{1-q^{n+1}}\right)\binom{n+1}{k}\\&amp;=\binom{n+1}{k}\end{aligned}\]</span></p><p>同理可得 <span class="math display">\[\binom{n}{k}+q^{n+1-k}\binom{n}{k-1}=\binom{n+1}{k}\]</span></p><p>显然可以用数学归纳法证明：</p><p><span class="math inline">\(n=1\)</span>显然。</p><p>设<span class="math inline">\(n=m\)</span>成立，那么当<spanclass="math inline">\(n=m+1\)</span>时，有： <spanclass="math display">\[\begin{aligned}&amp;(x+y)(x+qy)\cdots(x+q^{m-1}y)(x+q^my)\\&amp;=(x+q^my)\sum_{k=0}^{m}q^{\binom{k}{2}} \binom{m}{k}_qx^{m-k}y^k\\&amp;=\sum_{k=0}^{m}q^{\binom{k}{2}}\binom{m}{k}_qx^{m+1-k}y^k+\sum_{k=1}^{m+1}q^{\binom{k-1}{2}}q^m\binom{m}{k-1}_qx^{m+1-k}y^k\\&amp;=\binom{m}{0}_qx^{m+1} +\sum_{k=1}^{m}\left(\left(q^{\binom{k}{2}}\binom{m}{k}_q+q^{\binom{k-1}{2}+m} \binom{m}{k-1}_q\right)x^{m+1-k}y^k\right)+q^{\binom{m}{2}+\binom{m}{1}} \binom{m}{m}_qy^{m+1}\\&amp;=\binom{m+1}{0}_qx^{m+1}+\sum_{k=1}^{m}\left(q^{\binom{k}{2}}\left(\binom{m}{k}_q+q^{m+1-k}\binom{m}{k-1}_q \right)x^{m+1-k}y^k\right)+q^{\binom{m+1}{2}}y^{m+1}\\&amp;=\sum_{k=0}^{m+1}q^{\binom{k}{2}}\binom{m+1}{k}_qx^{m+1-k}y^k\end{aligned}\]</span> 证毕。</p><h2 id="section-13">50</h2><blockquote><p><img src="/images/image-20240929131531914.png"alt="image-20240929131531914" /> <imgsrc="/images/image-20240929131603989.png"alt="image-20240929131603989" /></p></blockquote><p>有 <span class="math display">\[\begin{aligned}g_n&amp;=\sum_{k=1}^{n} \binom{n-k}{k-1}\\&amp;=\sum_{k=1}^{n}\binom{n-k-1}{k-1}+\sum_{k=1}^{n}\binom{n-k-1}{k-2}\\&amp;=\sum_{k=1}^{n-1}\binom{n-1-k}{k-1}+\sum_{k=1}^{n}\binom{n-2-(k-1)}{k-1-1}\\&amp;=g_{n-1}+\sum_{k=0}^{n-1}\binom{n-2-k}{k-1}\\&amp;=g_{n-1}+\sum_{k=1}^{n-2}\binom{n-2-k}{k-1}\\&amp;=g_{n-1}+g_{n-2}\end{aligned}\]</span></p><h2 id="section-14">51</h2><blockquote><figure><img src="/images/image-20240929134343436.png"alt="image-20240929134343436" /><figcaption aria-hidden="true">image-20240929134343436</figcaption></figure></blockquote><p>有 <span class="math display">\[(1-3x)g(x)=2-4\sum_{n=1}^{\infty}nx^n\]</span> 故 <span class="math display">\[\begin{aligned}g(x)&amp;=\frac{2}{1-3x}-\frac{4}{1-3x} \sum_{n=1}^{\infty}nx^n\\&amp;=\frac{2}{1-3x}-\frac{4x}{1-3x}\sum_{n=0}^{\infty}\binom{n+1}{n}x^n\\&amp;=\frac{2}{1-3x}-\frac{4x}{1-3x}\frac{1}{(1-x)^2}\\&amp;=\frac{-1}{1-3x} + \frac{3-x}{(1-x)^2} \\&amp;=\sum_{n=0}^{\infty} (2n+3-3^n)x^n\end{aligned}\]</span></p>]]></content>
    
    
    
    <tags>
      
      <tag>combinatorics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5thCombinatorics6</title>
    <link href="/2024/09/30/5thCombinatorics6/"/>
    <url>/2024/09/30/5thCombinatorics6/</url>
    
    <content type="html"><![CDATA[<h1id="组合数学第五版答案-容斥原理及其应用">组合数学第五版答案-容斥原理及其应用</h1><blockquote><p>Richard A. Brualdi-Introductory Combinatorics (5th Edition) (2009)第六章的部分习题答案，直接套公式，书中有详细答案或与书中例题基本一致的题目省略。仅供参考。</p></blockquote><p>因本人水平有限，且没有标答验证，可能有错误，欢迎指正。</p><h2 id="section">3</h2><blockquote><p>Find the number of integers between 1 and 10,000 that are neitherperfect squares nor perfect cubes.</p></blockquote><p>如何找出既是完全平方数又是完全立方数的数？ 注意到<spanclass="math inline">\(x=a^2=b^3\)</span> 那么<spanclass="math inline">\(b=a^{\frac{2}{3}}\)</span>因此<spanclass="math inline">\(a^{\frac{1}{3}}\)</span>为整数,那么<spanclass="math inline">\(x=c^6\)</span>只需解<spanclass="math inline">\(c^6\leq10000\)</span>即可。</p><h2 id="section-1">19</h2><blockquote><p>Using the evaluation of the derangement numbers as given in Theorem6.3.1, provide a proof of the relation</p><p><span class="math display">\[D_n = (n-1)(D_{n-2} + D_{n-1}), \quad (n=3,4,5, ...).\]</span></p></blockquote><p><span class="math display">\[\begin{aligned}(n-1)(D_{n-1}+D_{n-2})&amp;=(n-1)\left((n-1)!\sum_{i=0}^{n-1}\frac{(-1)^i}{i!}+(n-2)!\sum_{i=0}^{n-2}\frac{(-1)^i}{i!}\right)\\&amp;=(n-1)\left((n-1)!+(n-2)!\right)\sum_{i=0}^{n-2}\frac{(-1)^i}{i!}+(n-1)\cdot(-1)^{n-1}\\&amp;=n!\sum_{i=0}^{n-2}\frac{(-1)^i}{i!}+n!\left(\frac{(-1)^{n-1}(n-1)}{n!}\right)\\&amp;=n!\sum_{i=0}^{n-2}\frac{(-1)^i}{i!}+n!\left(\frac{(-1)^{n-1}n}{n!}-(-1)^{n-1}\frac{1}{n!}\right)\\&amp;=D_n\end{aligned}\]</span></p><h2 id="section-2">21</h2><blockquote><p>Prove that <span class="math inline">\(D_n\)</span> is an even numberif and only if n is an odd number.</p></blockquote><p>可通过归纳法，或者：</p><p>可以根据 <span class="math display">\[D_n=n!\left(1-\frac{1}{1!}+\frac{1}{2!}-\frac{1}{3!}+\cdots+(-1)^n\frac{1}{n!}\right)\]</span> 单独考虑<span class="math inline">\(D_1\)</span>,然后 <spanclass="math display">\[D_n=(-1)^n \frac{n!}{n!} +(-1)^{n-1} \frac{n!}{(n-1)!}\cdots\]</span> 当<spanclass="math inline">\(n&gt;1\)</span>时，第三项后面项全是偶数，而第一项为奇数，第二项与n同奇偶，因此<spanclass="math inline">\(D_n\)</span>为偶数，当且仅当<spanclass="math inline">\(n\)</span>为奇数。</p><p>或者由于 <span class="math display">\[D_n=nD_{n-1}+(-1)^n\]</span> 递推一步，可得出： <span class="math display">\[D_{n+1}\equiv n(n+1)D_{n-1}+n \equiv n\mod{2}\]</span></p><h2 id="section-3">27</h2><blockquote><p>A carousel has eight seats, each representing a different animal.Eight girls are seated on the carousel facing forward (each girl ooks atanother girl's back). In how many ways can the girls change seats sothat each has a different girl in front of her? How does the problemchange if all the seats are identical?</p></blockquote><p>记<span class="math inline">\(A_i\)</span>表示排列<spanclass="math inline">\(s_1s_2 \cdots s_8\)</span>中<spanclass="math inline">\(s_i\)</span>面向<spanclass="math inline">\(s_{i+1}\)</span>（其中<spanclass="math inline">\(1 \le i \le 7\)</span>），<spanclass="math inline">\(A_8\)</span>表示表示排列<spanclass="math inline">\(s_1s_2 \cdots s_8\)</span>中<spanclass="math inline">\(s_8\)</span>面向<spanclass="math inline">\(s_1\)</span>。</p><p>单独考虑<span class="math inline">\(s_8\)</span>对<spanclass="math inline">\(s_1\)</span>的情况。</p><p><span class="math inline">\(|A_i|\)</span>：<spanclass="math inline">\(7!+6!=8\times 6!\)</span></p><p><span class="math inline">\(|A_iA_j|\)</span>：<spanclass="math inline">\(6!+2\times 5!=8\times 5!\)</span></p><p><span class="math inline">\(k\)</span>个相交为<spanclass="math inline">\((8-k)!+k\times(7-k)!=8\times (7-k)!\)</span></p><p>答案为13000</p><p>当所有座位都相同时，第一个选择的只有1种选法，其余人选法不变，因此排列总数为<spanclass="math inline">\(\frac{13000}{8} = 1625\)</span>。</p><h2 id="section-4">32</h2><blockquote><p>Let n be a positive integer and let<spanclass="math inline">\(p_1,p_2,\cdots,p_k\)</span>be all the differentprime numbers that divide n. Consider the Euler function <spanclass="math inline">\(\phi\)</span> defined by <spanclass="math display">\[\phi(n)=|\{k:1 \leq k\leq n,GCD(k,n)=1 \}|\]</span> Use the inclusion-exclusion principle to show that <spanclass="math display">\[\phi(n)=n\prod_{i=1}^{k} (1-\frac{1}{p_i})\]</span></p></blockquote><p>设<span class="math inline">\(A_i\)</span>为<spanclass="math inline">\(p_i|\gcd(k,n)\)</span>的集合。 <spanclass="math display">\[\begin{aligned}\phi(n)&amp;=|\overline{A_1}\cap \overline{A_2}\cap\cdots\cap\overline{A_k}|\\&amp;=n-\sum_{i}\left(\frac{n}{p_i}\right)+\sum_{i,j}\left(\frac{n}{p_ip_j}\right)-\cdots+(-1)^k(\frac{n}{p_1p_2\cdotsp_k})\\&amp;=n\prod_{i=1}^{k} (1-\frac{1}{p_i})\end{aligned}\]</span></p><h2 id="section-5">33</h2><blockquote><figure><img src="/images/image-20240824225321055.png"alt="image-20240824225321055" /><figcaption aria-hidden="true">image-20240824225321055</figcaption></figure></blockquote><p>等价于从围成一圈的<spanclass="math inline">\(1,2,\cdots,2n\)</span>选择不相邻的<spanclass="math inline">\(m\)</span>个数字。我们选出分成<spanclass="math inline">\(2n-k\)</span>和<spanclass="math inline">\(k\)</span>，从<spanclass="math inline">\(2n-k\)</span>中选出<spanclass="math inline">\(k\)</span>个空，每一种选择可进行旋转，有<spanclass="math inline">\(\frac{2n}{2n-k}\)</span>种。所以 <spanclass="math display">\[a(n,k)=\frac{2n}{2n-k} \binom{2n-k}{k}\]</span> 或者：</p><p>若不考虑<spanclass="math inline">\(1，2n\)</span>，我们可以假设选择<spanclass="math inline">\(c_1,c_2,\cdots,c_k\)</span>，其中小于<spanclass="math inline">\(c_i\)</span>的有<spanclass="math inline">\(x_i\)</span>个，大于<spanclass="math inline">\(c_k\)</span>的有<spanclass="math inline">\(x_{k+1}\)</span>个。那么我们有 <spanclass="math display">\[x_1+x_2+\cdots +x_{k+1}=2n-k\]</span> 然后先在两两中间插入一个，转化为 <span class="math display">\[y_1+y_2+\cdots+y_{k+1}=2n-2k+1\]</span> 其中<span class="math inline">\(0\leq y_i\leq 2n-2k+1\)</span>，有<span class="math inline">\(\binom{2n-k+1}{k}\)</span></p><p>假设选择<span class="math inline">\(2n\)</span>，那么 不能选择<spanclass="math inline">\(1,2n-1\)</span>,有<spanclass="math inline">\(\binom{2n-k-1}{k-1}\)</span></p><p>若不选择<span class="math inline">\(2n\)</span>，那么有<spanclass="math inline">\(\binom{2n-k}{k}\)</span></p><p>总数为 <span class="math display">\[\binom{2n-k-1}{k-1}+\binom{2n-k}{k}=\frac{k}{2n-k}\binom{2n-k}{k}+\binom{2n-k}{k}=\frac{2n}{2n-k}\binom{2n-k}{k}\]</span></p><blockquote><p>不知道为什么棋盘和下面的等价，带入k=1，显然是错的，可能是这些位置不是禁止，而是其他位置禁止，那么就显然等价了。</p><p>我们可以进行编号。例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1200</span><br><span class="hljs-number">0340</span><br><span class="hljs-number">0056</span><br><span class="hljs-number">8007</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="section-6">34</h2><blockquote><figure><img src="/images/image-20240824225329592.png"alt="image-20240824225329592" /><figcaption aria-hidden="true">image-20240824225329592</figcaption></figure></blockquote><p>交换求和次序即可。 <span class="math display">\[\begin{aligned}f*(g*h)(x,y)&amp;=\sum_{x\leq z\leq y}f(x,z)(g*h)(z,y)\\&amp;=\sum_{x\leq z\leq y}\left( f(x,z)\left(\sum_{z\leq w\leqy}g(z,w)h(w,y) \right)\right)\\&amp;=\sum_{x\leq z\leq y} \left(\sum_{z\leq w\leq y}f(x,z)g(z,w)h(w,y)\right)\\&amp;=\sum_{x\leq w\leq y}\left(\sum_{x\leq z\leq w}f(x,z)g(z,w)\right)h(w,y)\\&amp;=\sum_{x\leq w\leq y}(f*g)(x,w)h(w,y)\\&amp;=(f*g)*h\end{aligned}\]</span></p><h2 id="section-7">36</h2><blockquote><figure><img src="/images/image-20240824225335976.png"alt="image-20240824225335976" /><figcaption aria-hidden="true">image-20240824225335976</figcaption></figure></blockquote><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[<span class="hljs-number">30</span>][<span class="hljs-number">30</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin &gt;&gt; n;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>      cin &gt;&gt; a[i][j];<br>    &#125;<br>  &#125;<br>  ll ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1ll</span> &lt;&lt; n); ++i) &#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; S;<br>    <span class="hljs-comment">// subset S</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (i &gt;&gt; j &amp; <span class="hljs-number">1</span>) &#123;<br>        S.<span class="hljs-built_in">push_back</span>(j + <span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>    ll p = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; ++k) &#123;<br>      ll sum = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; x : S) sum += a[k][x];<br>      p *= sum;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((n - S.<span class="hljs-built_in">size</span>()) &amp; <span class="hljs-number">1</span>) &#123;<br>      ans -= p;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      ans += p;<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-8">37</h2><blockquote><figure><img src="/images/image-20240824225341561.png"alt="image-20240824225341561" /><figcaption aria-hidden="true">image-20240824225341561</figcaption></figure></blockquote><p>赋值法。</p><p>设<span class="math inline">\(f*g=\delta\)</span> <spanclass="math display">\[\delta(A,B)=\sum_{A\subseteq C \subseteq B} f(A,C) g(C,B)\]</span></p><ul><li><p>若<span class="math inline">\(A=B\)</span>：</p><p>那么 <span class="math display">\[f(A,A)g(A,A)=1\Rightarrow g(A,A)=1\]</span> <span class="math inline">\(g(A,B)=1\)</span></p></li><li><p>若<span class="math inline">\(|B|-|A|=1\)</span></p><p>那么 <span class="math display">\[\begin{aligned}0&amp;=f(A,A)g(A,B)+f(A,B)g(B,B)\\&amp;=g(A,B)+2\end{aligned}\]</span> <span class="math inline">\(g(A,B)=-2\)</span></p></li><li><p>若<span class="math inline">\(|B|-|A|=2\)</span></p><p>那么 <span class="math display">\[\begin{aligned}0&amp;=f(A,A)g(A,B)+f(A,C)g(C,B)+f(A,B)g(B,B) \\&amp;=g(A,B)+2g(C,B)+1\\&amp;=g(A,B)-4+1\end{aligned}\]</span> <span class="math inline">\(g(A,B)=3\)</span></p></li><li><p>若<span class="math inline">\(|B|-|A|=3\)</span></p><p>那么 <span class="math display">\[\begin{aligned}0&amp;=f(A,A)g(A,B)+f(A,C)g(C,B)+f(A,D)g(D,B)+f(A,B)g(B,B) \\&amp;=g(A,B)+2g(C,B)+g(D,B)-1 \\&amp;=g(A,B)+6-2-1\\\end{aligned}\]</span> <span class="math inline">\(g(A,B)=-3\)</span></p></li></ul><p>综上</p><p>若<span class="math inline">\(A\subseteq B\)</span> <spanclass="math display">\[g(A,B)=\begin{cases}1&amp;\qquad,A=B\\-2&amp;\qquad,|B|-|A|=1\\3&amp;\qquad,|B|-|A|=2\\-3&amp;\qquad,|B|-|A|=3\end{cases}\]</span></p><h2 id="section-9">38</h2><blockquote><figure><img src="/images/image-20240824225346059.png"alt="image-20240824225346059" /><figcaption aria-hidden="true">image-20240824225346059</figcaption></figure></blockquote><p>以<span class="math inline">\(\Pi_3\)</span>为例： <spanclass="math display">\[\begin{aligned}\sigma_1&amp;=\{\{ 1,2,3\}\}\\\sigma_2&amp;=\{\{ 1\},\{ 2,3\}\}\\\sigma_3&amp;=\{\{ 1,2\},\{ 3\}\}\\\sigma_4&amp;=\{\{ 1,3\},\{ 2\}\}\\\sigma_5&amp;=\{\{ 1\},\{ 2\},\{3\}\}\\\end{aligned}\]</span></p><ul><li><p>若<span class="math inline">\(|\sigma|-|\pi|=1\)</span> <spanclass="math display">\[\begin{aligned}\mu(\sigma,\pi)=-\left(\mu(\sigma,\sigma )\right)=-1\end{aligned}\]</span></p></li><li><p>若<span class="math inline">\(|\sigma|-|\pi|=2\)</span> <spanclass="math display">\[\mu(\sigma,\pi)=-\left(\mu(\sigma,\sigma)+\mu(\sigma,\sigma_2)+\mu(\sigma,\sigma_3)+\mu(\sigma,\sigma_4)\right)=-(1-3)=2\]</span></p></li></ul><h2 id="section-10">39</h2><blockquote><figure><img src="/images/image-20240824225352287.png"alt="image-20240824225352287" /><figcaption aria-hidden="true">image-20240824225352287</figcaption></figure></blockquote><p>等价于证明<span class="math inline">\(\forall a\in X_n,\mu(1,k)=\mu(a,ka)\)</span>对任意正整数成立(满足<spanclass="math inline">\(ka\leq n\)</span>)</p><p>考虑使用数学归纳法</p><ul><li><p><span class="math inline">\(k=1\)</span>,显然成立</p></li><li><p>假设对于任意<span class="math inline">\(x\leq t-1\)</span>成立。<span class="math display">\[\begin{aligned}\mu(1,t)&amp;=-\sum_{x|t,x&lt;t}\mu(1,x)\\&amp;=-\sum_{x|t,x&lt;t}\mu(a,xa)\\&amp;=\mu(a,ta)\end{aligned}\]</span></p></li></ul><p>证毕。</p><h2 id="section-11">40</h2><blockquote><figure><img src="/images/image-20240824225358425.png"alt="image-20240824225358425" /><figcaption aria-hidden="true">image-20240824225358425</figcaption></figure></blockquote><p>这里略过证明偏序关系的过程。</p><p>这个偏序集是<spanclass="math inline">\(k\)</span>个线性有序集的笛卡尔积。因此可以得到</p><p>设<span class="math inline">\(A=p_i\cdot a_i\)</span>，<spanclass="math inline">\(B=q_i\cdot a_i\)</span>，<spanclass="math inline">\(A\leq B\)</span>，<spanclass="math inline">\(m=\max_{1\leq i \leq k}{(q_i-p_i)}\)</span>，<spanclass="math inline">\(c=\sum_{1\leq i\leq k}[q_i-p_i=1]\)</span> <spanclass="math display">\[\mu(A,B)=\begin{cases}1&amp;\qquad,m=0\\(-1)^c&amp;\qquad,m=1\\0&amp;\qquad,m&gt;1\end{cases}\]</span></p>]]></content>
    
    
    
    <tags>
      
      <tag>combinatorics</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
