<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/11/22/Combinatorics/"/>
    <url>/2024/11/22/Combinatorics/</url>
    
    <content type="html"><![CDATA[<blockquote><p>加训组合。​</p></blockquote><h1 id="公式">公式</h1><h2 id="排列组合">排列组合</h2><h3 id="排列">排列</h3><h4 id="线性排列">线性排列</h4><p><span class="math display">\[P(n,r)=\frac{n!}{\left(n-r\right)!}\]</span></p><h4 id="圆排列">圆排列</h4><p><span class="math inline">\(n\)</span> 个数的<spanclass="math inline">\(r\)</span>排列数是 <span class="math display">\[\frac{P(n,r)}{r}\]</span></p><h4 id="项链数">项链数</h4><p><span class="math inline">\(n\)</span>个不同的珠子串成一串项链,则得到不同的项链数为 <spanclass="math display">\[p=\begin{cases}1,\  \ \left( n&lt;=2\right) \\\frac{(n-1)!}{2},\   \ \left( otherwise\right)\end{cases}\]</span></p><h4 id="多重集的排列">多重集的排列</h4><p>有<span class="math inline">\(k\)</span> 种元素,每种<spanclass="math inline">\(n_1,n_2,\dots n_k\)</span>个,的排列公式 <spanclass="math display">\[\frac{n!}{\prod_{i=1}^{k}\left(n_i!\right)}\]</span> 或记为<span class="math display">\[\binom{n}{n1,n2,\cdots,n_k}\]</span></p><h5 id="例子">例子</h5><p>在<span class="math inline">\(n\times n\)</span>的棋盘摆放<spanclass="math inline">\(n\)</span>个棋子,使得每行每列只有一个的摆放方法有<spanclass="math inline">\(n!\)</span>种. 若有<spanclass="math inline">\(k\)</span>种颜色,分别为 <spanclass="math inline">\(n_1,n_2,\dots n_k\)</span> 个,则摆放方法有 <spanclass="math display">\[n!\cdot\frac{n!}{\prod_{i=1}^{k}\left(n_i!\right)}\]</span></p><h3 id="组合">组合</h3><p><span class="math display">\[\binom{n}{r}=\frac{P(n,r)}{r!}\]</span></p><h4 id="多重集的组合">多重集的组合</h4><p>设<span class="math inline">\(S\)</span>是有<spanclass="math inline">\(k\)</span> 种元素的集合,每种元素无限个<spanclass="math inline">\((\geq r)\)</span>,则其<spanclass="math inline">\(r\)</span> 组合的个数为 <spanclass="math display">\[\binom{r+k-1}{r} \]</span> <strong>证明:</strong>设第<span class="math inline">\(i\)</span>种元素有<spanclass="math inline">\(x_i\)</span> 个,显然有<spanclass="math inline">\(x_1+x_2+\dots+x_k=r(x_i\geq 0)\)</span>该题就转化求解的个数. 设$T={r,(k-1)| } <spanclass="math inline">\(,\)</span>|<spanclass="math inline">\(分割为\)</span>k$ 个区域,第<spanclass="math inline">\(i\)</span> 个区域的<spanclass="math inline">\(1\)</span> 的个数对应<spanclass="math inline">\(x_i\)</span>,故多重集合<spanclass="math inline">\(T\)</span> 的排列数就是该题答案,为<spanclass="math display">\[\frac{(r+k-1)!}{r!(k-1)!}=\binom{r+k-1}{r}\]</span></p><h4 id="组合恒等式">组合恒等式</h4><p>一般采用<strong>双计数</strong>方法证明.即<strong>算两次</strong>的技巧</p><h4 id="pascal公式">1(Pascal公式)</h4><p><spanclass="math display">\[\binom{n}{k}=\binom{n-1}{k}+\binom{n-1}{k-1}\]</span></p><h4 id="section">2</h4><p><span class="math display">\[\sum_{i=0}^{n} \binom{n}{i}=2^n\]</span></p><h4 id="section-1">3</h4><p><span class="math display">\[ m\cdot \binom{n}{m}=n\cdot\binom{n-1}{m-1} \]</span></p><h4 id="section-2">4</h4><p><span class="math display">\[ \sum_{i=1}^{n}k\cdot\binom{n}{k}=n\cdot \sum_{i=1}^{n}\binom{n-1}{k-1}=n\cdot2^{n-1}\]</span></p><h4 id="朱世杰恒等式">3(朱世杰恒等式)</h4><p><span class="math display">\[\binom{m+n+1}{n+1}=\sum_{i=0}^{m} \binom{n+i}{n}\]</span></p><p><strong>证明:</strong> 注意到<spanclass="math inline">\((x+1)^{m+n+1}\)</span>的<spanclass="math inline">\(x^{n+1}\)</span> 的系数为<spanclass="math inline">\(\binom{m+n+1}{n+1}\)</span>,而我们可以将其看成<spanclass="math inline">\(m+n+1\)</span> 个<spanclass="math inline">\((x+1)\)</span>相乘,取了<spanclass="math inline">\(n+1\)</span> 次<spanclass="math inline">\(x\)</span>,设<spanclass="math inline">\(c_i\)</span> 为第<spanclass="math inline">\(i\)</span>项为第一次取<spanclass="math inline">\(x\)</span> 的种类数,那么$c_i= $ 其中$1 im+2 $ 又有<span class="math display">\[\sum_{i=1}^{m+1} \binom{m+n+1-i}{n}=\sum_{i=1}^{m+1} \binom{n+i-1}{n}=\sum_{i=0}^{m} \binom{n+i}{n}\]</span> 得证.</p><h4 id="范德蒙德恒等式">4(范德蒙德恒等式)</h4><p><span class="math display">\[\binom{a+b}{n}=\sum_{i=0}^{k}\binom{a}{i}\binom{b}{n-i}\]</span></p><p><strong>特别地</strong>: <span class="math display">\[\binom{2n}{n}=\sum_{i=0}^{n}\binom{n}{i}\binom{n}{n-i}\]</span></p><h5 id="例1">例1</h5><p>证明<span class="math inline">\(m\)</span> 个<spanclass="math inline">\(a\)</span>,和最多<spanclass="math inline">\(n\)</span> 个b的排列数等于 <spanclass="math display">\[\binom{m+n+1}{m+1} \]</span><strong>证明:</strong> 先排<spanclass="math inline">\(a\)</span>,然后再<spanclass="math inline">\(m+1\)</span>个位置插入<spanclass="math inline">\(b\)</span>,满足<spanclass="math inline">\(x_1+x_2+\dots +x_{m+1}\leq n\)</span> 令<spanclass="math inline">\(y=n-左式 \geq0\)</span>,且<spanclass="math inline">\(y+左式=n\)</span>,解的个数为 <spanclass="math display">\[\binom{m+n+1}{m+1} \]</span></p><h5 id="例2">例2</h5><p>证明:最多 <span class="math inline">\(m\)</span> 个<spanclass="math inline">\(a\)</span>,和最多<spanclass="math inline">\(n\)</span> 个b的排列数等于 <spanclass="math display">\[\binom{n+m+2}{m+1}-1\]</span> <strong>证明:</strong> <span class="math display">\[\iff\sum_{i=0}^{m} \binom{i+n+1}{n}=\sum_{i=0}^{m+1}\binom{i+n}{n}-1=\binom{n+m+2}{m+1}-1\]</span></p><h2 id="二项式系数">二项式系数</h2><h3 id="帕斯卡三角形">帕斯卡三角形</h3><p>本章核心<strong>帕斯卡公式</strong> <span class="math display">\[\binom{n}{k}=\binom{n-1}{k}+\binom{n-1}{k-1}\]</span></p><h3 id="二项式定理">二项式定理</h3><p><span class="math display">\[(x+y)^n=\sum_{k=0}^{n}\binom{n}{k}x^{n-k}y^{k}\]</span></p><h4 id="单峰性">单峰性</h4><p>二项式系数是单峰序列 最大项为</p><p><span class="math display">\[\binom{n}{\lfloor \frac{n}{2} \rfloor} and\binom{n}{\lceil\frac{n}{2}\rceil}\]</span></p><h4 id="sperner定理">Sperner定理</h4><p>设<span class="math inline">\(S\)</span>是<spanclass="math inline">\(n\)</span> 元素集合.那么<spanclass="math inline">\(S\)</span>上的一个反链至多包含$ $个集合.</p><h3 id="多项式定理">多项式定理</h3><h4 id="多项式系数">多项式系数</h4><p><span class="math display">\[\binom{n}{n_1,n_2,\dots,n_t}=\frac{n!}{n_1!n_2!\cdots n_t!}\]</span></p><p>从而 <span class="math display">\[\binom{n}{k}=\binom{n}{k,n-k}\]</span></p><h4 id="多项式系数的帕斯卡公式">多项式系数的帕斯卡公式</h4><p><span class="math display">\[\binom{n}{n_1,n_2,\cdots,n_t}=\binom{n-1}{n_1-1,n_2,\cdots,n_t}+\binom{n-1}{n_1,n_2-1,\cdots,n_t}+\cdots+\binom{n-1}{n_1,n_2,\cdots,n_t-1}\]</span></p><h4 id="多项式定理-1">多项式定理</h4><p><span class="math display">\[(x_1+s_2+\cdots+x_t)^n=\sum\binom{n}{n_1,n_2,\cdots,n_t}x_1^{n_1}x_x^{n_2}\cdots x_t^{n_t}\]</span></p><h4 id="牛顿多项式定理">牛顿多项式定理</h4><p>特殊的有 <span class="math display">\[(1+z)^a=\sum_{k=0}^{\infty} \binom{a}{n} z^k(a\in R,|z|&lt;1)\]</span></p><h3 id="偏序集">偏序集</h3><p>设<span class="math inline">\((X,\leq)\)</span>是有限偏序集合,而<spanclass="math inline">\(r\)</span>是链的最大大小,则<spanclass="math inline">\(X\)</span>可以被划分为<spanclass="math inline">\(r\)</span>个反链,但不能被划分成小于<spanclass="math inline">\(r\)</span>个反链.</p><h4 id="dilworth定理">Dilworth定理</h4><p>设<span class="math inline">\((X,\leq)\)</span>是有限偏序集合,而<spanclass="math inline">\(m\)</span>是反链的最大大小,则<spanclass="math inline">\(X\)</span>可以被划分为<spanclass="math inline">\(m\)</span>个链,但不能被划分成小于<spanclass="math inline">\(m\)</span>个链. <span class="math display">\[\begin{align*}\binom{n-1}{k-1}+ \binom{n-1}{k} =&amp; \frac{(n-1)!}{(k-1)!(n-k)!} +\frac{(n-1)!}{k!(n-k-1)!} \\=&amp;\frac{(n-1)!}{(k-1)!(n-k-1)!} \times(\frac{1}{n-k}+ \frac{1}{k})\\=&amp;\frac{(n-1)!}{(k-1)!(n-k-1)!} \times \frac{k+(n-k)}{k(n-k)} \\=&amp;\frac{n!}{k!(n-k)!} = \binom{n}{k}\end{align*}\]</span></p><h2 id="抽屉原理">抽屉原理</h2><h3 id="简单形式">简单形式</h3><p>如果要把<span class="math inline">\(n+1\)</span>个物体放进<spanclass="math inline">\(n\)</span>个盒子,那么至少有一个盒子有至少<spanclass="math inline">\(2\)</span>个物体</p><h3 id="加强形式">加强形式</h3><p>设<span class="math inline">\(q_1,q_2,\dots q_n\)</span>是正整数.如果将<span class="math inline">\(q_1+q_2+\dots+q_n-n+1\)</span>个物体放进<span class="math inline">\(n\)</span>个盒子.那么要么要么第一个盒子含有<spanclass="math inline">\(q_1\)</span>个物体,<spanclass="math inline">\(\dots\)</span> ,要么第<spanclass="math inline">\(n\)</span> 个物体含有<spanclass="math inline">\(q_n\)</span>个物体.</p><h2 id="ramsey定理">Ramsey定理</h2><h3 id="基本形式">基本形式</h3><p>在<span class="math inline">\(6\)</span>个人(或者更多),要么有<spanclass="math inline">\(3\)</span>个人互相认识,要么有<spanclass="math inline">\(3\)</span>个人互相都不认识.</p><h3 id="抽象化">抽象化</h3><p>对于<span class="math inline">\(K_n(n \geq6)\)</span>我们给他的所有边染红色或蓝色,总存在一个红<spanclass="math inline">\(K_3\)</span> 或蓝<spanclass="math inline">\(K_3\)</span>,记为<spanclass="math inline">\(K_6\rightarrow K_3,K_3\)</span></p><h4 id="证明">证明</h4><p>对于任意一点<span class="math inline">\(p\)</span>,从他出去有<spanclass="math inline">\(5\)</span>条边,因为红和蓝地位等价,不妨设,红比蓝多.由抽屉原理,红色边数量至少是<spanclass="math inline">\(3\)</span>,对于这<spanclass="math inline">\(3\)</span>跳边对应的三个顶点之间的三条边,若一条然红色就会有一个红<spanclass="math inline">\(K_3\)</span>,否则有一个蓝<spanclass="math inline">\(K_3\)</span>.</p><h3 id="一般化">一般化</h3><p>若$m,n <span class="math inline">\(,存在正整数\)</span>p<spanclass="math inline">\(,使得\)</span>K_pK_m,K_n $</p><p>事实上,注意到若<span class="math inline">\(p\)</span>成立,则对于<spanclass="math inline">\(q\geq p\)</span>都成立,取一个子图即可.我们记Ramsey数<spanclass="math inline">\(r(m,n)\)</span>为使之成立的最小的数.Ramsey定理保证这样的数一定存在.注意到<span class="math display">\[r(m,n)=r(n,m)\]</span> 以及<spanclass="math display">\[r(2,m)=m \]</span> 当<spanclass="math inline">\(m\geq2\)</span>时,<spanclass="math inline">\(r(2,m)\)</span>称为平凡的Ramsey数(交换同理).</p><h4 id="证明-1">证明</h4><p>使用数学归纳法. 我们有<spanclass="math inline">\(r(m,2),r(2,n)\)</span>成立.然后由$r(m-1,n),r(m,n-1)r(m,n) $即可.</p><h4 id="性质">性质</h4><ol type="1"><li><span class="math display">\[r(m,n)\leq r(m-1,n)+r(m,n-1)(m,n \geq3) \]</span></li><li><span class="math display">\[r(m,n)\leq \binom{m+n-2}{n-1}\]</span>(数学归纳法证明)</li></ol><h2 id="容斥原理">容斥原理</h2><p><span class="math display">\[|A_1\cup A_2\cup \cdots\cup A_n|=\sum_{i=1}^{n}|A_i|-\sum_{1\leqi&lt;j\leq n}|A_i\cap A_j|+\sum_{1\leq i&lt;j&lt;k\leq n} |A_i\capA_j\cap A_k|+\cdots+(-1)^{n-1}|A_1\cap A_2\cap \cdots \cap A_n|\]</span></p><p><strong>数学归纳法</strong>容易证明</p><p>或者根据以下方法</p><h3 id="推论">推论</h3><p><span class="math display">\[|\overline{A_1}\cap \overline{A_2} \cap \cdots \cap\overline{A_n}|=|S|-\sum|A_i|+\sum|A_i\cap A_j|+\cdots+(-1)^n|A_1\capA_2\cap \cdots \cap A_n|\]</span></p><p><strong>proof:</strong></p><p>证明根据右式,满足左式的元素,贡献为1,反之为0</p><p>设x满足左式,根据右式计算为<spanclass="math inline">\(1-0+0-0\cdots=1\)</span></p><p>否则设其属于<spanclass="math inline">\(m\)</span>个子集,则根据右式计算为<spanclass="math inline">\(1-\binom{n}{1}+\binom{n}{2}-\cdots=0\)</span>.</p><p><strong>QED</strong></p><h3 id="应用不定方程整数解个数问题">应用:不定方程整数解个数问题</h3><p><strong>例</strong></p><p>求下列方程整数解个数 <span class="math display">\[x_1+x_2+x_3+x_4=18\]</span> 满足 <span class="math display">\[1\leq x_1 \leq 5 ,\quad -2\leq x_2\leq4,\quad0\leq x_3\leq 5,\quad 3\leqx_4\leq 9\]</span> <strong>解:</strong></p><p>等价于 <span class="math display">\[a_1+a_2+a_3+a_4=16\]</span> 满足 <span class="math display">\[0\leq a_1 \leq 4 ,\quad 0\leq a_2\leq6,\quad0\leq a_3\leq 5,\quad 0\leqa_4\leq 6\]</span> 不加范围的解的个数为 <span class="math display">\[|S|=\binom{16+4-1}{16}=969\]</span> 其中设<span class="math inline">\(A_1\)</span>为<spanclass="math inline">\(a_1\)</span>大于<spanclass="math inline">\(4\)</span>的解的集合<spanclass="math inline">\(A_2\)</span>为<spanclass="math inline">\(a_2\)</span>大于6的解的集合<spanclass="math inline">\(\cdots\)</span> <span class="math display">\[\begin{align*}|A_1|=&amp;\binom{11+4-1}{11}=364\\|A_2|=&amp;\binom{9+4-1}{9}=220\\|A_3|=&amp;\binom{13}{10}=286\\|A_4|=&amp;\binom{12}{9}=220\\\end{align*}\]</span> 同理算交集.然后根据容斥原理可得出答案为<spanclass="math inline">\(55\)</span></p><h3 id="错位排列">错位排列</h3><p><span class="math display">\[D_n=n!\left(1-\frac{1}{1!}+\frac{1}{2!}-\frac{1}{3!}+\cdots+(-1)^n\frac{1}{n!}\right)\]</span></p><p>注意到 <span class="math display">\[\frac{D_n}{n!}\approx e^{-1}\]</span> 或者递推式</p><p><span class="math inline">\(D_1=0,D_2=1\)</span> <spanclass="math display">\[D_n=(n-1)(D_{n-1}+D_{n-2})\]</span></p><p><span class="math display">\[\begin{align*}&amp;D_n=(n-1)(D_{n-1}+D_{n-2})\\\iff&amp;D_n-nD_{n-1}=-(D_{n-1}-(n-1)D_{n-2})\\\iff&amp;D_n=nD_{n-1}+(-1)^n\end{align*}\]</span></p><hr /><p><span class="math display">\[Q_n=n!-\binom{n-1}{1}(n-1)!+\binom{n-1}{2}(n-2)!-\binom{n-1}{3}(n-3)!+\cdots+(-1)^{n-1}\binom{n-1}{n-1}1!\]</span></p><p>为不出现<span class="math inline">\(i(i+1)\)</span>的排列数</p><p>并且有 <span class="math display">\[Q_n=D_n+D_{n-1}\]</span></p><h2 id="莫比乌斯反演">莫比乌斯反演</h2><h3 id="容斥原理-1">容斥原理</h3><p>对于一个偏序集$((X_n),) <spanclass="math inline">\(,(\)</span>X_n<spanclass="math inline">\(为\)</span>n<spanclass="math inline">\(元集),若\)</span>$ F,G:(X_n)R <spanclass="math display">\[且\]</span> G(K)=<em>{LK} F(L)(KX_n) <span class="math display">\[那么根据容斥原理,设$A_i$为没有其种一个元素的子集的函数值之和.那么有\]</span> F(K)=</em>{LK} (-1)^{|K|-|L|}G(L) $$有容斥原理另外一种形式:</p><p><img src="/images/屏幕截图%202024-08-15%20112252.png" /></p><p>那么 <span class="math display">\[G(K)=\left|\bigcap_{i\notin K} A_i\right|\]</span> 因为我们考虑<span class="math inline">\(\forall x\in\bigcap_{i\notin K} A_i\)</span></p><p>被计数,只需要将所有包含他的$iK <spanclass="math inline">\(的\)</span>A_i$移除即可,且只可能一次.</p><p>那么我们取<span class="math inline">\(K=\{1,2,\cdots,n\}\)</span></p><p>此时<span class="math inline">\(F(K)=|\overline{A_1}\cap\overline{A_2} \cap \cdots \cap \overline{A_n}|\)</span></p><p>故得到 <span class="math display">\[|\overline{A_1}\cap \overline{A_2} \cap \cdots \cap\overline{A_n}|=\sum_{J\subseteq K} (-1)^{|J|} \left|\bigcap_{i\in J}A_i\right|\]</span></p><h3 id="三种特殊函数leftxleqright">三种特殊函数<spanclass="math inline">\(\left((X,\leq)\right)\)</span></h3><p>:<span class="math inline">\(X\times X \rightarrow R\)</span></p><h4 id="卷积公式">卷积公式</h4><p><span class="math inline">\(h=f*g\)</span> <spanclass="math display">\[h(x,y)=\begin{cases} \sum_{z:x\leq z\leq y} f(x,z)g(z,y)\qquad&amp;,x\leq y\\ 0\qquad &amp;,other\end{cases}\]</span></p><h4 id="科罗内尔delta函数">科罗内尔delta函数</h4><p><span class="math display">\[\delta(x,y)=\begin{cases}1\qquad ,x=y\\ 0\qquad,other\end{cases}\]</span></p><p>有<span class="math inline">\(f*\delta=\delta*f=f\)</span></p><h4 id="zeta函数"><span class="math inline">\(\zeta\)</span>函数</h4><p><span class="math display">\[\zeta(x,y)=\begin{cases}1\qquad,x\leq y\\ 0\qquad,other\end{cases}\]</span></p><p>对于<span class="math inline">\(X\)</span>中所有的<spanclass="math inline">\(y\)</span>满足<spanclass="math inline">\(f(y,y)\neq 0\)</span>,有其逆函数</p><h4 id="逆函数">逆函数</h4><p><img src="/images/屏幕截图%202024-08-16%20112617.png" /></p><p>对于(6.16)到(6.17)</p><p>有 <span class="math display">\[0=g(x,y)-g(x,y)=-\frac{1}{f(y,y)}\left(g(x,y)f(y,y)+\sum_{x\leq z&lt;y }g(x,z) f(z,y) \right)\]</span> 对于满足<span class="math inline">\(f(y,y)\neq 0\)</span>的函数都有逆函数<span class="math inline">\(g\)</span> <spanclass="math display">\[f*g=g*f=\delta\]</span></p><h4 id="莫比乌斯函数">莫比乌斯函数</h4><p><span class="math inline">\(\zeta\)</span>函数的逆函数</p><p>那么有 <span class="math display">\[\sum_{x\leq z \leq y} \mu(x,z)\zeta(z,y)=\delta(x,y)\]</span> 得出 <span class="math display">\[\mu(x,y)=\begin{cases}1&amp;\qquad,x=y\\\\-\sum_\limits{x\leq z&lt;y} \mu(x,z)&amp;\qquad ,x&lt;y\end{cases}\]</span></p><h3 id="莫比乌斯反演-1">莫比乌斯反演</h3><p><img src="/images/屏幕截图%202024-08-16%20121057.png" /></p><p><img src="/images/屏幕截图%202024-08-16%20121122.png" /></p><p>由该定理可以证明本节给出的容斥原理.</p><h3id="应用计算有禁止位置的非攻击型车的方法数">应用:计算有禁止位置的非攻击型车的方法数</h3><p><span class="math inline">\(n\times n\)</span> 棋盘 <spanclass="math display">\[F(X_n)=\sum_{S\subseteq X_n} (-1)^{n-|S|}\prod_{i=1}^{n}\left(\sum_{j\inS} a_{ij}\right)\]</span></p><p>其中<span class="math inline">\(S\)</span>为<spanclass="math inline">\(X_n\)</span>的子集，<spanclass="math inline">\(a_{ij}\)</span>为棋盘对应的矩阵。</p><h4 id="代码">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[<span class="hljs-number">30</span>][<span class="hljs-number">30</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin &gt;&gt; n;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>      cin &gt;&gt; a[i][j];<br>    &#125;<br>  &#125;<br>  ll ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1ll</span> &lt;&lt; n); ++i) &#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; S;<br>    <span class="hljs-comment">// subset S</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (i &gt;&gt; j &amp; <span class="hljs-number">1</span>) &#123;<br>        S.<span class="hljs-built_in">push_back</span>(j + <span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>    ll p = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; ++k) &#123;<br>      ll sum = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; x : S) sum += a[k][x];<br>      p *= sum;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((n - S.<span class="hljs-built_in">size</span>()) &amp; <span class="hljs-number">1</span>) &#123;<br>      ans -= p;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      ans += p;<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度<span class="math inline">\(O(n^2\cdot2^n)\)</span></p><h3 id="直积的莫比乌斯函数">直积的莫比乌斯函数</h3><p><img src="/images/屏幕截图%202024-08-19%20111903.png" /></p><h3 id="常用莫比乌斯函数">常用莫比乌斯函数</h3><h4 id="mathcalpx_nsubseteq"><spanclass="math inline">\((\mathcal{P}(X_n),\subseteq)\)</span></h4><p><span class="math inline">\(\mu(A,B)=(-1)^{|B|-|A|}\)</span></p><h4 id="x_nleq"><span class="math inline">\((X_n,\leq)\)</span></h4><p><span class="math display">\[\mu(k,l)=\begin{cases}1&amp;\qquad,l=k\\-1&amp;\qquad,l=k+1\\0&amp;\qquad,other\end{cases}\]</span></p><h4 id="x_n"><span class="math inline">\((X_n,|)\)</span></h4><p><span class="math display">\[\mu(1,n)=\begin{cases}1&amp;\qquad,n=1\\(-1)^k&amp;\qquad,n是互不相同的素数乘积\\0,&amp;\qquad,other\end{cases}\]</span></p><p>且有莫比乌斯反演公式 <span class="math display">\[G(n)=\sum_{k|n} F(k)\]</span></p><p><span class="math display">\[F(k)=\sum_{k|n}\mu(k,n)G(k)=\sum_{k|n}\mu(1,\frac{n}{k})G(k)\]</span></p><h1 id="递推关系与生成函数">递推关系与生成函数</h1><h2 id="斐波拉契数列">斐波拉契数列</h2><h3 id="性质1">性质1</h3><p><span class="math display">\[\sum_{i=0}^{n} f_i=f_{n+2}-1\]</span></p><h3 id="性质2">性质2</h3><p><span class="math display">\[2|f_n\iff3|n\]</span></p><h2 id="生成函数">生成函数</h2><h3 id="牛顿二项式定理">牛顿二项式定理</h3><figure><img src="/images/image-20240907103752300.png"alt="image-20240907103752300" /><figcaption aria-hidden="true">image-20240907103752300</figcaption></figure><p>对于<span class="math inline">\(|z|&lt;1\)</span> <spanclass="math display">\[(1+z)^{\alpha}=\sum_{k=0}^{\infty} \binom{\alpha}{k}z^k\]</span> <img src="/images/image-20240907104309955.png"alt="image-20240907104309955" /></p><h3 id="一般生成函数">一般生成函数</h3><p>根据泰勒级数 <span class="math display">\[\frac{1}{1-x}=\sum_{n=0}^{\infty}x^n\]</span> 我们可以解<span class="math inline">\(h_n\)</span>表示 <spanclass="math display">\[e_1+e_2+\cdots+e_k=n\]</span> 的非负整数解的个数。</p><p>其生成函数为 <span class="math display">\[g(x)=\frac{1}{(1-x)^k}\]</span></p><p>同时类似的数列，可以给因子附加限制求解生成函数。</p><p>具体的，对于<span class="math inline">\(l\leq e_i \leqr\)</span>其因子为 <span class="math display">\[x^l+x^{l+1}+\cdots + x^{r}\]</span> 若其有系数<span class="math inline">\(k\)</span>，为 <spanclass="math display">\[1+x^k+x^{2k}+\cdots\]</span> <img src="/images/image-20240903175101111.png"alt="image-20240903175101111" /></p><figure><img src="/images/image-20240903175116759.png"alt="image-20240903175116759" /><figcaption aria-hidden="true">image-20240903175116759</figcaption></figure><p>考虑逆序列唯一对应排序。</p><h3 id="指数生成函数">指数生成函数</h3><p>形如</p><figure><img src="/images/image-20240903175240924.png"alt="image-20240903175240924" /><figcaption aria-hidden="true">image-20240903175240924</figcaption></figure><figure><img src="/images/image-20240903175322134.png"alt="image-20240903175322134" /><figcaption aria-hidden="true">image-20240903175322134</figcaption></figure><p>对无限多也成立。</p><h2 id="线性齐次递推关系">线性齐次递推关系</h2><figure><img src="/images/image-20240907104818031.png"alt="image-20240907104818031" /><figcaption aria-hidden="true">image-20240907104818031</figcaption></figure><figure><img src="/images/image-20240907104842123.png"alt="image-20240907104842123" /><figcaption aria-hidden="true">image-20240907104842123</figcaption></figure><p>由范德蒙德矩阵可得，只有<spanclass="math inline">\(q_i\)</span>不相等才有解。</p><h3id="利用生成函数解线性其次递推关系">利用生成函数解线性其次递推关系</h3><figure><img src="/images/image-20240907105143727.png"alt="image-20240907105143727" /><figcaption aria-hidden="true">image-20240907105143727</figcaption></figure><figure><img src="/images/image-20240907105318205.png"alt="image-20240907105318205" /><figcaption aria-hidden="true">image-20240907105318205</figcaption></figure><p>有重根的情况，有定理： <img src="/images/image-20240907105441524.png"alt="image-20240907105441524" /></p><h3 id="非齐次递推关系">非齐次递推关系</h3><p>求特解</p><figure><img src="/images/image-20240907105802249.png"alt="image-20240907105802249" /><figcaption aria-hidden="true">image-20240907105802249</figcaption></figure><h1 id="stage1">stage1</h1><blockquote><p>cf：1600~2100</p></blockquote><blockquote><p>date: 24.11.23</p></blockquote><h2 id="day1">day1</h2><h3 id="math">math</h3><h3 id="acm">acm</h3><h4 id="g.-natlan-exploring"><ahref="https://codeforces.com/problemset/problem/2037/G">G. NatlanExploring</a></h4><p>对于<spanclass="math inline">\(x\)</span>，如何求值。如果其含质因数<spanclass="math inline">\(A_1,A_2,\dots\)</span>，可以用容斥原理求出来。因为最多含<spanclass="math inline">\(7\)</span>个不同的质因数。</p><p>我们可以先用筛法求出最小的质因数，可以<spanclass="math inline">\(\log\)</span>级别分解质因数。<spanclass="math inline">\(\sqrt{n}\)</span>也可以接受。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; p[N];<br>ll cnt[<span class="hljs-number">1000009</span>];<br>ll f[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; pri;<br>bitset&lt;1000009&gt; not_pri;<br><span class="hljs-type">int</span> minp[<span class="hljs-number">1000009</span>];  <span class="hljs-comment">// 最小质因数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Euler</span><span class="hljs-params">(<span class="hljs-type">int</span> n = <span class="hljs-number">1e6</span>)</span> </span>&#123;<br>  minp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (!not_pri[i]) pri.<span class="hljs-built_in">push_back</span>(i), minp[i] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : pri) &#123;<br>      <span class="hljs-keyword">if</span> (i * p &gt; n) <span class="hljs-keyword">break</span>;<br>      not_pri[i * p] = <span class="hljs-number">1</span>;<br>      minp[i * p] = p;<br>      <span class="hljs-keyword">if</span> (i % p == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">Euler</span>();<br>  <span class="hljs-type">int</span> n;<br>  cin &gt;&gt; n;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-type">int</span> x;<br>    cin &gt;&gt; x;<br>    <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-type">int</span> y = minp[x];<br>      p[i].<span class="hljs-built_in">push_back</span>(y);<br>      <span class="hljs-keyword">while</span> (x % y == <span class="hljs-number">0</span>) x /= y;<br>    &#125;<br>  &#125;<br>  f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; (<span class="hljs-number">1</span> &lt;&lt; p[i].<span class="hljs-built_in">size</span>()); ++j) &#123;<br>      <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>, c = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; p[i].<span class="hljs-built_in">size</span>(); ++k) &#123;<br>        <span class="hljs-keyword">if</span> (j &gt;&gt; k &amp; <span class="hljs-number">1</span>) &#123;<br>          res *= p[i][k];<br>          c++;<br>        &#125;<br>      &#125;<br>      f[i] += (c % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>) * cnt[res];<br>      f[i] = (f[i] % mod + mod) % mod;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; (<span class="hljs-number">1</span> &lt;&lt; p[i].<span class="hljs-built_in">size</span>()); ++j) &#123;<br>      <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>, c = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; p[i].<span class="hljs-built_in">size</span>(); ++k) &#123;<br>        <span class="hljs-keyword">if</span> (j &gt;&gt; k &amp; <span class="hljs-number">1</span>) res *= p[i][k];<br>      &#125;<br>      cnt[res] += f[i];<br>      cnt[res] %= mod;<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; f[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>利用莫比乌斯反演形式的容斥原理。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Combinatorics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cu</title>
    <link href="/2024/11/18/Cu/"/>
    <url>/2024/11/18/Cu/</url>
    
    <content type="html"><![CDATA[<hr /><blockquote><p>难度不超过铜牌题的XCPC题</p></blockquote><h2 id="the-2023-icpc-asia-jinan-regional-contest"><ahref="https://codeforces.com/gym/104901">The 2023 ICPC Asia JinanRegional Contest</a></h2><h3 id="a.-many-many-heads贪心">A. Many Many Heads（贪心）</h3><p>连续相同的不超过2</p><p>连续2个的不超过2次</p><h3 id="g.-gifts-from-knowledge并查集2-sat典"><font color=Orange>G.Gifts from Knowledge</font>(并查集，2-SAT)（典）</h3><p>第<span class="math inline">\(i\)</span>和<spanclass="math inline">\(c+1-i\)</span>列总数，不能超过3个。</p><p>维护相同相反关系，无向图。</p><p>tarjan换并查集即可。</p><p>方法数即是<span class="math inline">\(2^{连通块数/2}\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REP(i, n) for (int i = 1; i &lt;= (n); ++i)</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pii;<br><span class="hljs-keyword">typedef</span> pair&lt;ll, ll&gt; pll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-comment">// using i128=__int128_t;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e6</span> + <span class="hljs-number">9</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> iinf = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">const</span> ll linf = <span class="hljs-number">1e18</span>;<br><span class="hljs-comment">// i&lt;&lt;1 false, i&lt;&lt;1|1 true</span><br><span class="hljs-type">int</span> pre[N];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">root</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> pre[x] = (pre[x] == x ? x : <span class="hljs-built_in">root</span>(pre[x])); &#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; pre[<span class="hljs-built_in">root</span>(x)] = <span class="hljs-built_in">root</span>(y); &#125;<br><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll a, ll k, ll p)</span> </span>&#123;<br>  ll res = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (k) &#123;<br>    <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) res = res * a % p;<br>    a = a * a % p;<br>    k &gt;&gt;= <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> r, c;<br>  cin &gt;&gt; r &gt;&gt; c;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= (r &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>); ++i) pre[i] = i;<br>  vector&lt;<span class="hljs-type">int</span>&gt; a[c + <span class="hljs-number">1</span>];<br>  <span class="hljs-built_in">REP</span>(i, r) <span class="hljs-built_in">REP</span>(j, c) &#123;<br>    <span class="hljs-type">char</span> x;<br>    cin &gt;&gt; x;<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-string">&#x27;1&#x27;</span>) a[j].<span class="hljs-built_in">push_back</span>(i);<br>  &#125;<br>  <span class="hljs-built_in">REP</span>(i, (c + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">if</span> (a[i].<span class="hljs-built_in">size</span>() + a[c + <span class="hljs-number">1</span> - i].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">2</span>) &#123;<br>      cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (c &amp; <span class="hljs-number">1</span> &amp;&amp; a[(c + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-built_in">REP</span>(i, c / <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-type">int</span> j = c + <span class="hljs-number">1</span> - i;<br>    <span class="hljs-keyword">if</span> (a[i].<span class="hljs-built_in">size</span>() + a[j].<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-keyword">if</span> (a[i].<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">merge</span>(a[i][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">1</span>, a[i][<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">merge</span>(a[i][<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">1</span>, a[i][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[j].<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">merge</span>(a[j][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">1</span>, a[j][<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">merge</span>(a[j][<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">1</span>, a[j][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[i][<span class="hljs-number">0</span>] != a[j][<span class="hljs-number">0</span>]) &#123;<br>        <span class="hljs-built_in">merge</span>(a[i][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">1</span>, a[j][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">merge</span>(a[i][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, a[j][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= r; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">root</span>(i &lt;&lt; <span class="hljs-number">1</span>) == <span class="hljs-built_in">root</span>(i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>)) &#123;<br>      cout &lt;&lt; <span class="hljs-string">&quot;0\n&quot;</span>;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">root</span>(i &lt;&lt; <span class="hljs-number">1</span>) == (i &lt;&lt; <span class="hljs-number">1</span>)) cnt++;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">root</span>(i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>) == (i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>)) cnt++;<br>  &#125;<br>  cout &lt;&lt; <span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>, cnt / <span class="hljs-number">2</span>, mod) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="k.-rainbow-subarray-动态维护区间中位数典"><font color=Orange>K.Rainbow Subarray </font>(动态维护区间中位数)（典）</h3><p>假设一个区间中的某个数是<spanclass="math inline">\(a_i+k\)</span></p><p>我们希望计算这个柿子 <span class="math display">\[\sum_{j} |a_i+k+j-i-a_j|\]</span> 即 <span class="math display">\[\sum_j|a_i-i-(a_j-j)+k|\]</span> 先进行<span class="math inline">\(a_i:=a_i-i\)</span></p><p>就变成了 <span class="math display">\[\sum_{j}|a_i-a_j+k|\]</span> 注意到此时是需要将一个区间内所有数变相同。</p><p>直接注意到<span class="math inline">\(a_{i+1}-a_i=1\iff a_{i+1}-(i+1)=a_i-i\)</span>也行。</p><p>而需要的最小操作显然是变成中位数。</p><p>该代码可以在<span class="math inline">\(O(\log{n})\)</span>求出中位数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FindMedianSet</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  multiset&lt;T&gt; less, greater;<br>  ll LessSum = <span class="hljs-number">0</span>, GreaterSum = <span class="hljs-number">0</span>;<br>  T inf = numeric_limits&lt;T&gt;::<span class="hljs-built_in">max</span>();<br>  <span class="hljs-built_in">FindMedianSet</span>() &#123;<br>    LessSum = <span class="hljs-number">0</span>, GreaterSum = <span class="hljs-number">0</span>;<br>    less.<span class="hljs-built_in">clear</span>(), greater.<span class="hljs-built_in">clear</span>();<br>    less.<span class="hljs-built_in">insert</span>(-inf), greater.<span class="hljs-built_in">insert</span>(inf);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">adjust</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (less.<span class="hljs-built_in">size</span>() &gt; greater.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">typename</span> multiset&lt;T&gt;::iterator it = (--less.<span class="hljs-built_in">end</span>());<br>      GreaterSum += *it;<br>      LessSum -= *it;<br>      greater.<span class="hljs-built_in">insert</span>(*it);<br>      less.<span class="hljs-built_in">erase</span>(it);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (less.<span class="hljs-built_in">size</span>() &lt; greater.<span class="hljs-built_in">size</span>()) &#123;<br>      <span class="hljs-keyword">typename</span> multiset&lt;T&gt;::iterator it = greater.<span class="hljs-built_in">begin</span>();<br>      GreaterSum -= *it;<br>      LessSum += *it;<br>      less.<span class="hljs-built_in">insert</span>(*it);<br>      greater.<span class="hljs-built_in">erase</span>(it);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (val &lt;= *greater.<span class="hljs-built_in">begin</span>()) &#123;<br>      less.<span class="hljs-built_in">insert</span>(val);<br>      LessSum += val;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      greater.<span class="hljs-built_in">insert</span>(val);<br>      GreaterSum += val;<br>    &#125;<br>    <span class="hljs-built_in">adjust</span>();<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(T val)</span> </span>&#123;<br>    <span class="hljs-keyword">typename</span> multiset&lt;T&gt;::iterator it = less.<span class="hljs-built_in">find</span>(val);<br>    <span class="hljs-keyword">if</span> (it != less.<span class="hljs-built_in">end</span>()) &#123;<br>      less.<span class="hljs-built_in">erase</span>(it);<br>      LessSum -= val;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      it = greater.<span class="hljs-built_in">find</span>(val);<br>      greater.<span class="hljs-built_in">erase</span>(it);<br>      GreaterSum -= val;<br>    &#125;<br>    <span class="hljs-built_in">adjust</span>();<br>  &#125;<br>  <span class="hljs-function">T <span class="hljs-title">get_Median</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> *less.<span class="hljs-built_in">rbegin</span>(); &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>维护两个<code>multiset</code>，L，G。表示小于等于中位数的集合，和大于等于中位数的集合。</p><p>在满足<code>0&lt;=L.size()-G.size()&lt;=1</code>的时候，L里的最大值即是中位数。用<code>adjust</code>函数维护这一性质。</p><p>回到本题。使用二分会超时，注意到一个区间可以，其子区间也可以。可以用双指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  ll n, k;<br>  cin &gt;&gt; n &gt;&gt; k;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">p</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-built_in">REP</span>(i, n) cin &gt;&gt; a[i], a[i] -= i;<br>  FindMedianSet&lt;<span class="hljs-type">int</span>&gt; st;<br>  <span class="hljs-keyword">auto</span> check = [&amp;](<span class="hljs-type">int</span> x) &#123;<br>    st.<span class="hljs-built_in">insert</span>(a[x]);<br>    ll res = st.GreaterSum - st.LessSum;<br>    <span class="hljs-keyword">if</span> ((st.greater.<span class="hljs-built_in">size</span>() + st.less.<span class="hljs-built_in">size</span>()) &amp; <span class="hljs-number">1</span>) res += st.<span class="hljs-built_in">get_Median</span>();<br>    <span class="hljs-keyword">if</span> (res &lt;= k) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    st.<span class="hljs-built_in">erase</span>(a[x]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;;<br>  <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> L = <span class="hljs-number">1</span>, R = <span class="hljs-number">0</span>; L &lt;= n; ++L) &#123;<br>    <span class="hljs-keyword">while</span> (R + <span class="hljs-number">1</span> &lt;= n &amp;&amp; <span class="hljs-built_in">check</span>(R + <span class="hljs-number">1</span>)) R++;<br>    ans = <span class="hljs-built_in">max</span>(ans, R - L + <span class="hljs-number">1</span>);<br>    st.<span class="hljs-built_in">erase</span>(a[L]);<br>  &#125;<br>  cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="the-2023-icpc-asia-hangzhou-regional-contest"><ahref="https://codeforces.com/gym/104976">The 2023 ICPC Asia HangzhouRegional Contest</a></h2><h3 id="d.operator-precedence构造">D.Operator Precedence(构造)</h3><p>注意到乘积不会很大。假设右式为<spanclass="math inline">\(a_1a_{2n}\)</span> （其余为1）。</p><p>我们可以再给<spanclass="math inline">\(a_{2n}\)</span>赋值。此时希望<spanclass="math inline">\(a_1\)</span>有整数解。</p><p>注意到<span class="math inline">\(a_1\)</span>的系数为<spanclass="math inline">\(a_2-1\)</span>，不妨设。<spanclass="math inline">\(a_2\)</span>为2，解出<spanclass="math inline">\(a_1\)</span>即可。</p><h3 id="g.-snake-move-最短路"><font color=Orange>G. Snake Move</font>(最短路)</h3><p>如果不管身体，显然直接BFS就可以了。</p><p>利用dijsktra的话，可以保证最短路是第一次到该位置产生的。</p><p>剩下的就是怎么计算身体位置的值。</p><p>对第<span class="math inline">\(i\)</span>节身体，当权值大于了<spanclass="math inline">\(k-i+1\)</span>时，就不用管。</p><p>那么在松弛的时候取一下max即可。</p><p>而对于这个取模，实际上最大值是不会超过模数的。</p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, m, k;<br>  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">x</span><span class="hljs-params">(k + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">y</span><span class="hljs-params">(k + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-built_in">REP</span>(i, k) cin &gt;&gt; x[i] &gt;&gt; y[i];<br>  <span class="hljs-built_in">REP</span>(i, n) <span class="hljs-built_in">REP</span>(j, m) cin &gt;&gt; a[i][j];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k, j = <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">1</span>; --i, ++j) d[x[i]][y[i]] = j;<br>  priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, pii&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, pii&gt;&gt;, greater&lt;pair&lt;<span class="hljs-type">int</span>, pii&gt;&gt;&gt; q;<br>  q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, &#123;x[<span class="hljs-number">1</span>], y[<span class="hljs-number">1</span>]&#125;&#125;);<br>  ull ans = <span class="hljs-number">0</span>;<br>  vis[x[<span class="hljs-number">1</span>]][y[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>    <span class="hljs-keyword">auto</span> [dis, p] = q.<span class="hljs-built_in">top</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br>    ans += <span class="hljs-number">1ull</span> * dis * dis;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>      <span class="hljs-type">int</span> cx = p.first + dx[i], cy = p.second + dy[i];<br>      <span class="hljs-keyword">if</span> (cx &lt; <span class="hljs-number">1</span> || cx &gt; n || cy &lt; <span class="hljs-number">1</span> || cy &gt; m || vis[cx][cy] || a[cx][cy] == <span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">if</span> (!vis[cx][cy]) &#123;<br>        q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-built_in">max</span>(d[cx][cy], dis + <span class="hljs-number">1</span>), &#123;cx, cy&#125;&#125;);<br>        vis[cx][cy] = <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="china-collegiate-programming-contest-ccpc-jinan-site"><ahref="https://codeforces.com/gym/105540">2024 China CollegiateProgramming Contest (CCPC) Jinan Site</a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>ACM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>acm1600</title>
    <link href="/2024/10/02/acm/"/>
    <url>/2024/10/02/acm/</url>
    
    <content type="html"><![CDATA[<h2 id="abc-364-f---range-connect-mst">1.ABC 364 F - Range ConnectMST</h2><h3 id="problem-statement">Problem Statement</h3><p>There is a graph with <span class="math inline">\(N + Q\)</span>vertices, numbered <span class="math inline">\(1, 2, \ldots, N +Q\)</span>. Initially, the graph has no edges.</p><p>For this graph, perform the following operation for <spanclass="math inline">\(i = 1, 2, \ldots, Q\)</span> in order:</p><ul><li>For each integer <span class="math inline">\(j\)</span> satisfying<span class="math inline">\(L_i \leq j \leq R_i\)</span>, add anundirected edge with cost <span class="math inline">\(C_i\)</span>between vertices <span class="math inline">\(N + i\)</span> and <spanclass="math inline">\(j\)</span>.</li></ul><p>Determine if the graph is connected after all operations arecompleted. If it is connected, find the cost of a minimum spanning treeof the graph.</p><p>A minimum spanning tree is a spanning tree with the smallest possiblecost, and the cost of a spanning tree is the sum of the costs of theedges used in the spanning tree.</p><h3 id="constraints">Constraints</h3><ul><li><span class="math inline">\(1 \leq N, Q \leq 2 \times10^5\)</span></li><li><span class="math inline">\(1 \leq L_i \leq R_i \leq N\)</span></li><li><span class="math inline">\(1 \leq C_i \leq 10^9\)</span></li><li>All input values are integers.</li></ul><h3 id="思路">思路</h3><p>首先容易想到按边权排序。我们默认每一次操作至少添加一次，那么我们可以将<spanclass="math inline">\(N+1\simN+Q\)</span>看成已经联通，我们可以初始状态看成<spanclass="math inline">\(N+1\)</span>个连通块，目标是使最后只剩下一个联通块。而对于具体的一次操作我们显然需要连接范围内所有联通块。</p><h4 id="利用set">利用set</h4><p>注意到每一个连通块连接的点是连续的。我们用set储存每个连通块最小的点的编号，每次操作可以二分快速找到连通块数量。具体细节看代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>  <span class="hljs-type">int</span> l, r, c;<br>  <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node&amp; u) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> c &lt; u.c; &#125;<br>&#125; a[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, q;<br>  cin &gt;&gt; n &gt;&gt; q;<br>  set&lt;<span class="hljs-type">int</span>&gt; st;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) st.<span class="hljs-built_in">insert</span>(i);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; ++i) cin &gt;&gt; a[i].l &gt;&gt; a[i].r &gt;&gt; a[i].c;<br>  <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + q);<br>  ll ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; ++i) &#123;<br>    <span class="hljs-keyword">auto</span> s = st.<span class="hljs-built_in">upper_bound</span>(a[i].l), e = st.<span class="hljs-built_in">upper_bound</span>(a[i].r);<br>    s--, e--;<br>    ll cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (s != e) &#123;<br>      s++;<br>      <span class="hljs-keyword">while</span> (s != e) &#123;<br>        <span class="hljs-keyword">auto</span> it = ++s;<br>        s--;<br>        st.<span class="hljs-built_in">erase</span>(s);<br>        s = it;<br>        cnt++;<br>      &#125;<br>      cnt++;<br>      st.<span class="hljs-built_in">erase</span>(e);<br>    &#125;<br>    ans += cnt * a[i].c;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) ans = <span class="hljs-number">-1</span>;<br>  cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="利用并查集">利用并查集</h4><p>原理和用set类似。</p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>  <span class="hljs-type">int</span> l, r, c;<br>  <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node&amp; u) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> c &lt; u.c; &#125;<br>&#125; a[N];<br><span class="hljs-type">int</span> pre[N];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">root</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> pre[x] = (pre[x] == x ? x : <span class="hljs-built_in">root</span>(pre[x])); &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, q;<br>  cin &gt;&gt; n &gt;&gt; q;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) pre[i] = i;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; ++i) cin &gt;&gt; a[i].l &gt;&gt; a[i].r &gt;&gt; a[i].c;<br>  <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + q);<br>  ll ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; ++i) &#123;<br>    <span class="hljs-keyword">auto</span> [l, r, c] = a[i];<br>    ans += c;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">root</span>(l) != <span class="hljs-built_in">root</span>(r)) ans += c, pre[<span class="hljs-built_in">root</span>(r)] = <span class="hljs-built_in">root</span>(r) - <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">root</span>(<span class="hljs-number">1</span>) != <span class="hljs-built_in">root</span>(n)) ans = <span class="hljs-number">-1</span>;<br>  cout &lt;&lt; ans;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="利用线段树">利用线段树</h4><p>我们维护一个数组<span class="math inline">\(t\)</span>，若<spanclass="math inline">\(i\)</span>与<spanclass="math inline">\(i+1\)</span>联通，则为0否则为1。那么，<spanclass="math inline">\([l,r]\)</span>的联通块数量为<spanclass="math inline">\([l,r)\)</span>的和加1。证明很容易，不多赘述。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>  <span class="hljs-type">int</span> l, r, c;<br>  <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node&amp; u) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> c &lt; u.c; &#125;<br>&#125; a[N];<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls p &lt;&lt; 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs p &lt;&lt; 1 | 1</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tree</span> &#123;<br>  ll l, r, s, lz, mlz;<br>&#125; t[N &lt;&lt; <span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">mo</span><span class="hljs-params">(ll x)</span> </span>&#123; <span class="hljs-keyword">return</span> (x + mod) % mod; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(ll p)</span> </span>&#123; t[p].s = <span class="hljs-built_in">mo</span>(t[ls].s + t[rs].s); &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(ll p, ll k, ll x)</span> </span>&#123;<br>  t[p].s = <span class="hljs-built_in">mo</span>(<span class="hljs-built_in">mo</span>(t[p].s * k) + <span class="hljs-built_in">mo</span>(x * (t[p].r - t[p].l + <span class="hljs-number">1</span>)));<br>  t[p].mlz = <span class="hljs-built_in">mo</span>(t[p].mlz * k);<br>  t[p].lz = <span class="hljs-built_in">mo</span>(<span class="hljs-built_in">mo</span>(t[p].lz * k) + x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(ll p)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (t[p].lz == <span class="hljs-number">0</span> &amp;&amp; t[p].mlz == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-built_in">update</span>(ls, t[p].mlz, t[p].lz);<br>  <span class="hljs-built_in">update</span>(rs, t[p].mlz, t[p].lz);<br>  t[p].lz = <span class="hljs-number">0</span>, t[p].mlz = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ll p, ll l, ll r)</span> </span>&#123;<br>  t[p] = &#123;l, r, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>  <span class="hljs-keyword">if</span> (l == r) &#123;<br>    t[p].s = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  ll mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">build</span>(ls, l, mid);<br>  <span class="hljs-built_in">build</span>(rs, mid + <span class="hljs-number">1</span>, r);<br>  <span class="hljs-built_in">push_up</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(ll p, ll l, ll r, ll k, ll x)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span> (l &lt;= t[p].l <span class="hljs-keyword">and</span> r &gt;= t[p].r) &#123;<br>    <span class="hljs-built_in">update</span>(p, k, x);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-built_in">push_down</span>(p);<br>  <span class="hljs-keyword">if</span> (l &lt;= t[ls].r) <span class="hljs-built_in">modify</span>(ls, l, r, k, x);<br>  <span class="hljs-keyword">if</span> (r &gt;= t[rs].l) <span class="hljs-built_in">modify</span>(rs, l, r, k, x);<br>  <span class="hljs-built_in">push_up</span>(p);<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll p, ll l, ll r)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (l &lt;= t[p].l <span class="hljs-keyword">and</span> r &gt;= t[p].r) <span class="hljs-keyword">return</span> t[p].s;<br><br>  <span class="hljs-built_in">push_down</span>(p);<br>  ll res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (l &lt;= t[ls].r) res = <span class="hljs-built_in">mo</span>(res + <span class="hljs-built_in">query</span>(ls, l, r));<br>  <span class="hljs-keyword">if</span> (r &gt;= t[rs].l) res = <span class="hljs-built_in">mo</span>(res + <span class="hljs-built_in">query</span>(rs, l, r));<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, q;<br>  cin &gt;&gt; n &gt;&gt; q;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; ++i) cin &gt;&gt; a[i].l &gt;&gt; a[i].r &gt;&gt; a[i].c;<br>  <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + q);<br>  <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<br>  ll ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; ++i) &#123;<br>    <span class="hljs-keyword">auto</span> [l, r, c] = a[i];<br>    ans += c * (<span class="hljs-number">1</span> + <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, l, r - <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, l, r - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>)) ans = <span class="hljs-number">-1</span>;<br>  cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="abc-361-f---x-ab">2.ABC 361 F - x = a^b</h2><h3 id="problem-statement-1">Problem Statement</h3><p>How many integers <span class="math inline">\(x\)</span> between<span class="math inline">\(1\)</span> and <spanclass="math inline">\(N\)</span>, inclusive, can be expressed as <spanclass="math inline">\(x = a^b\)</span> using some positive integer <spanclass="math inline">\(a\)</span> and a positive integer <spanclass="math inline">\(b\)</span> <strong>not less than <spanclass="math inline">\(2\)</span></strong>?</p><h3 id="constraints-1">Constraints</h3><ul><li>All input values are integers.</li><li><span class="math inline">\(1 \le N \le 10^{18}\)</span></li></ul><h3 id="方法一">方法一</h3><p>答案为 <span class="math display">\[\sum_{i=1}^{n} [i可以被表示为a^b]\]</span></p><p>注意到，一个数如果可以表示为<spanclass="math inline">\(a^{kb}\)</span>那么它一定也可以被表示为<spanclass="math inline">\(a^b\)</span>，那么我们可以先只考虑<spanclass="math inline">\(b\)</span>为质数。我们先排除1，注意到<spanclass="math inline">\(2^{60}&gt;10^{18}\)</span>，那么我们可以只考虑<spanclass="math inline">\(60\)</span>以内的质数，只有17个。设其为<spanclass="math inline">\(p_i\)</span>，我们令<spanclass="math inline">\(A_i\)</span>表示可以表示为<spanclass="math inline">\(a^{p_i}\)</span>的个数。那么答案显然为 <spanclass="math display">\[|A_1\cup A_2\cup \cdots\cup A_n|\]</span> 利用容斥原理显然可以解决。</p><p>但是由于精度问题，我们不能直接<code>pow(n,1.0/x)</code>解<spanclass="math inline">\(\sqrt[x]{n}\)</span>，或者解出来后在向左右分别枚举一下，python是可以解决的。但是c++不行。</p><p>但是因为这几个质数乘积要小于<spanclass="math inline">\(60\)</span>。实际需要解的数量是很少的，且<spanclass="math inline">\(x&gt;2\)</span>从1枚举也只需要<spanclass="math inline">\(1e6\)</span>，因此可以直接枚举。而<spanclass="math inline">\(x=2\)</span>时，也不能用<code>sqrt()</code>,得用<code>sqrtl()</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> pri[] = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">23</span>, <span class="hljs-number">29</span>, <span class="hljs-number">31</span>, <span class="hljs-number">37</span>, <span class="hljs-number">41</span>, <span class="hljs-number">43</span>, <span class="hljs-number">47</span>, <span class="hljs-number">53</span>, <span class="hljs-number">59</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nr</span><span class="hljs-params">(ll n, ll r)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (r == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrtl</span>(n);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pow</span>(i, r) &gt; n) &#123;<br>      <span class="hljs-keyword">return</span> i - <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  ll n;<br>  cin &gt;&gt; n;<br>  <span class="hljs-type">int</span> up = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (; up &lt; <span class="hljs-number">17</span>; ++up) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1ll</span> &lt;&lt; pri[up] &gt; n) <span class="hljs-keyword">break</span>;<br>  &#125;<br>  ll ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; (<span class="hljs-number">1ll</span> &lt;&lt; up); ++i) &#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, r = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">17</span>; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (i &gt;&gt; j &amp; <span class="hljs-number">1</span>) cnt++, r *= pri[j];<br>      <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">60</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">60</span>) &#123;<br>      ans += (cnt % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>) * (<span class="hljs-built_in">nr</span>(n, r) - <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; ans + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二">方法二</h3><p>不妨设<span class="math inline">\(f(x)\)</span>为<spanclass="math inline">\(2\sim n\)</span>仅可表示为<spanclass="math inline">\(a^x\)</span>的个数，<spanclass="math inline">\(g(x)\)</span>为可以表示为<spanclass="math inline">\(a^x\)</span>的个数。</p><p>那么显然有 <span class="math display">\[f(x)=g(x)-f(2x)-f(3x)\cdots\]</span> 从后向前递推即可。</p><p>到这里发现，前面的代码能过是<strong>运气好</strong>。因为<code>pow</code>还是会错。参考答案可以自己写个<code>pow</code>函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">safe_pow</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;<br>  ll res = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">0</span>; i &lt; b; i++) &#123;<br>    <span class="hljs-type">double</span> dres = res;<br>    dres *= a;<br>    <span class="hljs-keyword">if</span> (dres &gt; <span class="hljs-number">2e18</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">2e18</span>;<br>    &#125;<br>    res *= a;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nr</span><span class="hljs-params">(ll n, ll r)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (r == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrtl</span>(n);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">safe_pow</span>(i, r) &gt; n) &#123;<br>      <span class="hljs-keyword">return</span> i - <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-type">int</span> f[<span class="hljs-number">100</span>], g[<span class="hljs-number">100</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  ll n;<br>  cin &gt;&gt; n;<br>  ll ans = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">60</span>; ++i) g[i] = <span class="hljs-built_in">nr</span>(n, i) - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">60</span>; x &gt;= <span class="hljs-number">2</span>; --x) &#123;<br>    f[x] = g[x];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">2</span>; k * x &lt;= <span class="hljs-number">60</span>; ++k) f[x] -= f[k * x];<br>    ans += f[x];<br>  &#125;<br>  cout &lt;&lt; ans;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们也可以用二分来替换开根运算，保证精度。<del>但是懒得写</del></p><h2 id="abc362-f---perfect-matching-on-a-tree">3.ABC362 F - PerfectMatching on a Tree</h2><h3 id="problem-statement-2">Problem Statement</h3><p>You are given a tree <span class="math inline">\(T\)</span> with<span class="math inline">\(N\)</span> vertices. The vertices arenumbered <span class="math inline">\(1\)</span> to <spanclass="math inline">\(N\)</span>, and the <spanclass="math inline">\(i\)</span>-th edge <span class="math inline">\((1\leq i \leq N-1)\)</span> connects vertices <spanclass="math inline">\(u_i\)</span> and <spanclass="math inline">\(v_i\)</span> bidirectionally.</p><p>Using <span class="math inline">\(T\)</span>, define a complete graph<span class="math inline">\(G\)</span> with <spanclass="math inline">\(N\)</span> vertices as follows:</p><ul><li>The weight <span class="math inline">\(w(x,y)\)</span> of the edgebetween vertices <span class="math inline">\(x\)</span> and <spanclass="math inline">\(y\)</span> in <spanclass="math inline">\(G\)</span> is the shortest distance betweenvertices <span class="math inline">\(x\)</span> and <spanclass="math inline">\(y\)</span> in <spanclass="math inline">\(T\)</span>.</li></ul><p>Find one <strong>maximum weight maximum matching</strong> in <spanclass="math inline">\(G\)</span>. That is, find a set of <spanclass="math inline">\(\lfloor N/2 \rfloor\)</span> pairs of vertices<span class="math inline">\(M=\{(x_1,y_1),(x_2,y_2),\dots,(x_{\lfloorN/2 \rfloor},y_{\lfloor N/2 \rfloor})\}\)</span> such that each vertex<span class="math inline">\(1,2,\dots, N\)</span> appears in <spanclass="math inline">\(M\)</span> at most once, and <spanclass="math inline">\(\displaystyle \sum_{i=1}^{\lfloor N/2 \rfloor}w(x_i,y_i)\)</span> is maximized.</p><h3 id="constraints-2">Constraints</h3><ul><li><span class="math inline">\(2 \leq N \leq 2 \times10^5\)</span></li><li><span class="math inline">\(1 \leq u_i  &lt; v_i \leqN\)</span></li><li>The input graph is a tree.</li><li>All input values are integers.</li></ul><h3 id="思路-1">思路</h3><p>考虑计算一条边可能被计算的次数。易证，边<spanclass="math inline">\((x,y)\)</span>最多被计算<spanclass="math inline">\(\min(size_x,size_y)\)</span>次。考虑每一条边都能达到上界。</p><p>下面构造一种方案能够达到上界。</p><p>引入树的重心的概念：</p><p>树的重心是以其为根节点时的<strong>最大子树大小</strong>最小。下面给出一些性质。</p><ol type="1"><li>等价于最大子树大小不超过<spanclass="math inline">\(\frac{n}{2}\)</span>。</li><li>树最多2个重心，且此时树有偶数个节点，且重心两两相邻。</li><li>树中所有点到某个点的<strong>距离和</strong>中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。反过来，距离和最小的点一定是重心。</li><li>往树上增加或减少一个<strong>叶子</strong>，如果原节点数是奇数，那么重心可能<strong>增加</strong>一个，原重心<strong>仍是重心</strong>；如果原节点数是偶数，重心可能<strong>减少</strong>一个，另一个重心<strong>仍是重心</strong>。</li><li>两棵树通过连一条边组合成新树，则新树重心在原来两棵树的重心的连线上。</li></ol><p>我们以树的重心为根，其有若干子树。且我们每条路径的两个点分别在两个子树上。</p><p>那么假设边<span class="math inline">\((x,y)\)</span>且<spanclass="math inline">\(y\)</span>是<spanclass="math inline">\(x\)</span>的父亲。则有<spanclass="math inline">\(x\)</span>的子树所有节点所匹配的点形成的路径一定会经过<spanclass="math inline">\((x,y)\)</span>。</p><p>下面考虑如何构造这样的方案。</p><p>首先，若节点数为偶数，那么最后会子树会剩下一个节点，容易发现将其与根节点匹配即可。然后我们考虑如何找到不同子树的点。注意到每个子树大小小于等于<spanclass="math inline">\(\frac{n}{2}\)</span>，且每颗子树的dfs序连续，那么我们可以找dfs序为<spanclass="math inline">\((i,i+\frac{n}{2})\)</span>的两个点。</p><h4 id="代码">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; g[N];<br><span class="hljs-type">int</span> si[N], cen, n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> pre)</span> </span>&#123;<br>  si[x] = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; y : g[x]) &#123;<br>    <span class="hljs-keyword">if</span> (y == pre) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-built_in">dfs</span>(y, x);<br>    si[x] += si[y];<br>    mx = <span class="hljs-built_in">max</span>(mx, si[y]);<br>  &#125;<br>  mx = <span class="hljs-built_in">max</span>(mx, n - si[x]);<br>  <span class="hljs-keyword">if</span> (mx &lt;= n / <span class="hljs-number">2</span>) cen = x;<br>&#125;<br><br><span class="hljs-type">int</span> dfn[N], idx, hs[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> pre)</span> </span>&#123;<br>  dfn[x] = ++idx;<br>  hs[idx] = x;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; y : g[x]) &#123;<br>    <span class="hljs-keyword">if</span> (y == pre) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-built_in">dfs1</span>(y, x);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> x, y;<br>  cin &gt;&gt; n;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>    cin &gt;&gt; x &gt;&gt; y;<br>    g[x].<span class="hljs-built_in">push_back</span>(y);<br>    g[y].<span class="hljs-built_in">push_back</span>(x);<br>  &#125;<br>  <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">dfs1</span>(cen, cen);<br>  <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; ++i) cout &lt;&lt; hs[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; hs[i + n / <span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n / <span class="hljs-number">2</span>; ++i) cout &lt;&lt; hs[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; hs[i + n / <span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="shcpc">2024 SHCPC</h2><p>https://codeforces.com/gym/105229/attachments</p><h3 id="a.无线网络整点栅格统计">4. A.无线网络整点栅格统计</h3><p>已知正方形两点坐标<spanclass="math inline">\((x_1,y_1),(x_2,y_2)\)</span></p><p>令<code>dx=x2-x1,dy=y2-y1</code>，可以得到<code>x3=x1+dy,y3=y1-dx,x4=x3+dx,y4=y3+dy</code></p><h3 id="m.不共戴天">5. M.不共戴天</h3><p>注意到可以将其列成表格，</p><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>4</td><td>5</td><td>6</td></tr><tr><td>7</td><td>8</td><td>9</td></tr><tr><td>10</td><td>11</td><td>12</td></tr></tbody></table><p>那么所有横着连的不可能和竖着连的相同.且无法多连.枚举一排个数即可.</p><h2 id="d.-1-2-k-game博弈论">6. <strong>D. 1-2-KGame</strong>(博弈论)</h2><p>https://codeforces.com/contest/1194/problem/D 博弈论</p><p>我们可以列出每个位置的胜负情况.可发现会产生一个<spanclass="math inline">\(T=k+1\)</span>的循环.证明略.</p><h2 id="f---teleporting-takahashi-2-dp">7. <strong>F - TeleportingTakahashi 2</strong> (DP)</h2><p>https://atcoder.jp/contests/abc372/tasks/abc372_f DP</p><p>如果么没有多余的边,那么每次转移固定.且编号是可计算的.那么每次只需要,计算最多50次即可.</p><h3 id="code">code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, m, k;<br>  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>    <span class="hljs-type">int</span> x, y;<br>    cin &gt;&gt; x &gt;&gt; y;<br>    g.<span class="hljs-built_in">push_back</span>(&#123;x, y&#125;);<br>  &#125;<br>  <span class="hljs-keyword">auto</span> id = [&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> x) &#123; <span class="hljs-built_in">return</span> ((i - x) % n + n) % n == <span class="hljs-number">0</span> ? n : ((i - x) % n + n) % n; &#125;;<br>  f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, ff[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; ++i) &#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [x, y] : g) &#123;<br>      <span class="hljs-type">int</span> p = <span class="hljs-built_in">id</span>(y - <span class="hljs-number">1</span> == <span class="hljs-number">0</span> ? n : y - <span class="hljs-number">1</span>, i - <span class="hljs-number">1</span>);<br>      f[p] += ff[<span class="hljs-built_in">id</span>(x, i - <span class="hljs-number">1</span>)];<br>      f[p] %= mod;<br>      v.<span class="hljs-built_in">push_back</span>(p);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> x : v) ff[x] = f[x];<br>  &#125;<br>  ll ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) ans = (ans + f[i]) % mod;<br>  cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="g---add-and-multiply-queries树状数组">8.<strong>G - Add andMultiply Queries</strong>(树状数组)</h2><p>https://atcoder.jp/contests/abc368/tasks/abc368_g</p><p>注意到其不超过1e18，那么乘法最多不超过60次，因此大量<spanclass="math inline">\(b\)</span>数组是1，所以我们可以用<code>set</code>记录b数组非1的位置，并用树状数组维护区间和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; n;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i], <span class="hljs-built_in">add</span>(i, a[i]);<br>  set&lt;<span class="hljs-type">int</span>&gt; st;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    cin &gt;&gt; b[i];<br>    <span class="hljs-keyword">if</span> (b[i] &gt; <span class="hljs-number">1</span>) st.<span class="hljs-built_in">insert</span>(i);<br>  &#125;<br>  st.<span class="hljs-built_in">insert</span>(n + <span class="hljs-number">1</span>);<br>  <span class="hljs-type">int</span> q;<br>  cin &gt;&gt; q;<br>  <span class="hljs-keyword">while</span> (q--) &#123;<br>    <span class="hljs-type">int</span> op;<br>    cin &gt;&gt; op;<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-type">int</span> i, x;<br>      cin &gt;&gt; i &gt;&gt; x;<br>      <span class="hljs-built_in">add</span>(i, x - a[i]);<br>      a[i] = x;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-type">int</span> i, x;<br>      cin &gt;&gt; i &gt;&gt; x;<br>      <span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">count</span>(i)) st.<span class="hljs-built_in">erase</span>(i);<br>        b[i] = <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        b[i] = x;<br>        st.<span class="hljs-built_in">insert</span>(i);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-type">int</span> l, r;<br>      cin &gt;&gt; l &gt;&gt; r;<br>      ll ans = a[l++];<br>      <span class="hljs-comment">// cout &lt;&lt; ans &lt;&lt; endl;</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r;) &#123;<br>        <span class="hljs-type">int</span> up = <span class="hljs-built_in">min</span>(r, *st.<span class="hljs-built_in">lower_bound</span>(i));<br>        <span class="hljs-comment">//  cout &lt;&lt; up &lt;&lt; endl;</span><br>        ans += <span class="hljs-built_in">prefix</span>(up - <span class="hljs-number">1</span>) - <span class="hljs-built_in">prefix</span>(i - <span class="hljs-number">1</span>);<br>        ans = <span class="hljs-built_in">max</span>(ans + a[up], ans * b[up]);<br>        <span class="hljs-comment">// cout &lt;&lt; &quot;ans: &quot; &lt;&lt; ans &lt;&lt; &quot;\n&quot;;</span><br>        i = up + <span class="hljs-number">1</span>;<br>      &#125;<br>      cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="c---row-and-column-order构造">9.<strong>C - Row and ColumnOrder</strong>(构造)</h2><p>https://atcoder.jp/contests/arc181/tasks/arc181_c构造</p><h3 id="法一">法一</h3><p>一种简单的做法是，将<span class="math inline">\(S_j:=S_i\)</span>然后在加一个1。这样就能保证满足行，对于列，若我们按Q从后往前加，就能保证，前面的包含在后面的，且后面的1更多，因此也满足。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin &gt;&gt; n;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">q</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; p[i];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; q[i];<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ans</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = n; i &lt;= n; ++i, --j) &#123;<br>    ans[p[i]] = ans[p[i - <span class="hljs-number">1</span>]];<br>    ans[p[i]][q[j]] = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>      cout &lt;&lt; ans[i][j];<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="法二">法二</h3><p>我们递归的做，先将<spanclass="math inline">\(P_1\)</span>全填0，<spanclass="math inline">\(Q_n\)</span>全填1，然后删除这一行和列。</p><p>这样做，对于行，后填的填的1更多，且前面的含于后面。</p><p>对于列，同理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin &gt;&gt; n;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">q</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; p[i];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; q[i];<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ans</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>));<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">auto</span> dfs = [&amp;](<span class="hljs-keyword">auto</span>&amp; self, <span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">void</span> &#123;<br>    <span class="hljs-keyword">if</span> (x &gt; n) <span class="hljs-keyword">return</span>;<br>    c[p[x]] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (c[i]) <span class="hljs-keyword">continue</span>;<br>      ans[i][q[n + <span class="hljs-number">1</span> - x]] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">self</span>(self, x + <span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-built_in">dfs</span>(dfs, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>      cout &lt;&lt; ans[i][j];<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="d.-connect-the-dots并查集dp">10.D. Connect theDots(并查集+dp)</h2><p>https://codeforces.com/contest/2020/problem/D</p><p>并查集+dp</p><p>注意到d很小，因此可以枚举d，考虑将d当做一个常数。</p><p>对于固定的d，如果我们知道每一个点所能连接的最远的点。就可以轻松解决。</p><p>我们设<code>f[i][j]</code>为<spanclass="math inline">\(d=j\)</span>时，i的最远点。有状态转移方程 <spanclass="math display">\[f_{i,j}=\max(f_{i,j},(f_{i,j}\geq i+j)f_{i+1,j})\]</span></p><p><span class="math display">\[f_{i+j,j}=\max(f_{i+j,j},f_{i,j})\]</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, m;<br>  cin &gt;&gt; n &gt;&gt; m;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) pre[i] = i;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>      f[j][i] = j;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>    <span class="hljs-type">int</span> a, d, k;<br>    cin &gt;&gt; a &gt;&gt; d &gt;&gt; k;<br>    f[a][d] = <span class="hljs-built_in">max</span>(f[a][d], a + k * d);<br>  &#125;<br>  <span class="hljs-comment">//  d: 1~10</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (f[j - i][i] &gt;= j) &#123;<br>        f[j - i][i] = <span class="hljs-built_in">max</span>(f[j - i][i], f[j][i]);<br>        f[j][i] = f[j - i][i];<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= <span class="hljs-number">1</span>; --j) &#123;<br>      <span class="hljs-built_in">merge</span>(j, f[j][i]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">root</span>(i) == i) ans++;<br>  &#125;<br>  cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="b---improve-inversions贪心">11.<strong>B - ImproveInversions</strong>(贪心)</h2><p>https://atcoder.jp/contests/arc180/tasks/arc180_b</p><p>对于<spanclass="math inline">\(i\)</span>来说，我们在后面找比他小的然后从大到小交换是最好的。</p><p>那么我们从小到大枚举<spanclass="math inline">\(i\)</span>，然后从大到小交换，因为前面交换的都比<spanclass="math inline">\(i\)</span>小，那么不会影响<spanclass="math inline">\(i\)</span>的交换次数。</p><p>因此可以达到 <span class="math display">\[\sum_{i=1}^{n}\sum_{j=i+k}^{n}[a_j&lt;a_i]\]</span> 并且可以证明这是最大的。因为假设我们交换一次，<spanclass="math inline">\(x,y(x&lt;y)\)</span> ，那么，对于<spanclass="math inline">\(l\leq x-k\)</span>和<spanclass="math inline">\(l&gt;y-k\)</span>不会有影响。但对于<spanclass="math inline">\(x-k&lt;l\leq y-k\)</span>若<spanclass="math inline">\(l=x\)</span>，则一定减少一次，否则，至少可以保证不会变多。</p><p>因此这就是最大值。</p><h2 id="f---tree-degree-optimization贪心-prufer-序列">12.<strong>F -Tree Degree Optimization</strong>(贪心 prufer 序列)</h2><p>https://oi-wiki.org/graph/prufer/</p><h2 id="g---atcoder-tourdp最短路">13.<strong>G - AtCoderTour</strong>(DP/最短路)</h2><p>https://atcoder.jp/contests/abc358/tasks/abc358_g</p><p>容易想到它一定会走到一个终点并一直停在那里。</p><h3 id="法一-1">法一</h3><p>可以枚举终点<code>(i,j)</code>。只连接权值小于终点的点。定义权值为<code>a[i][j]-a[x][y]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ll a[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];<br>ll n, m, k, d[<span class="hljs-number">3000</span>];<br>vector&lt;pll&gt; g[<span class="hljs-number">3000</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">to_i</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> (x - <span class="hljs-number">1</span>) * m + y; &#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">0</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt; <span class="hljs-number">0</span> &amp;&amp; y &lt;= m; &#125;<br><br>bitset&lt;3000&gt; vis;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dij</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  vis = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2500</span>; ++i) d[i] = linf;<br>  d[x] = <span class="hljs-number">0</span>;<br>  priority_queue&lt;pll, vector&lt;pll&gt;, greater&lt;pll&gt;&gt; q;<br>  q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, x&#125;);<br>  <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>    <span class="hljs-keyword">auto</span> [_, id] = q.<span class="hljs-built_in">top</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span> (vis[id]) <span class="hljs-keyword">continue</span>;<br>    vis[id] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [y, z] : g[id]) &#123;<br>      <span class="hljs-keyword">if</span> (d[y] &gt; d[id] + z) &#123;<br>        d[y] = d[id] + z;<br>        q.<span class="hljs-built_in">push</span>(&#123;d[y], y&#125;);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>  <span class="hljs-type">int</span> si, sj;<br>  cin &gt;&gt; si &gt;&gt; sj;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>      cin &gt;&gt; a[i][j];<br>    &#125;<br>  &#125;<br>  ll ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (a[i][j] &lt; a[si][sj]) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ii = <span class="hljs-number">1</span>; ii &lt;= n; ++ii) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> jj = <span class="hljs-number">1</span>; jj &lt;= m; ++jj) &#123;<br>          g[<span class="hljs-built_in">to_i</span>(ii, jj)].<span class="hljs-built_in">clear</span>();<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ii = <span class="hljs-number">1</span>; ii &lt;= n; ++ii) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> jj = <span class="hljs-number">1</span>; jj &lt;= m; ++jj) &#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(ii + <span class="hljs-number">1</span>, jj)) &#123;<br>            <span class="hljs-keyword">if</span> (a[ii + <span class="hljs-number">1</span>][jj] &lt;= a[i][j]) g[<span class="hljs-built_in">to_i</span>(ii, jj)].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-built_in">to_i</span>(ii + <span class="hljs-number">1</span>, jj), a[i][j] - a[ii + <span class="hljs-number">1</span>][jj]&#125;);<br>            <span class="hljs-keyword">if</span> (a[ii][jj] &lt;= a[i][j]) g[<span class="hljs-built_in">to_i</span>(ii + <span class="hljs-number">1</span>, jj)].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-built_in">to_i</span>(ii, jj), a[i][j] - a[ii][jj]&#125;);<br>          &#125;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(ii, jj + <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">if</span> (a[ii][jj + <span class="hljs-number">1</span>] &lt;= a[i][j]) g[<span class="hljs-built_in">to_i</span>(ii, jj)].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-built_in">to_i</span>(ii, jj + <span class="hljs-number">1</span>), a[i][j] - a[ii][jj + <span class="hljs-number">1</span>]&#125;);<br>            <span class="hljs-keyword">if</span> (a[ii][jj] &lt;= a[i][j]) g[<span class="hljs-built_in">to_i</span>(ii, jj + <span class="hljs-number">1</span>)].<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-built_in">to_i</span>(ii, jj), a[i][j] - a[ii][jj]&#125;);<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-built_in">dij</span>(<span class="hljs-built_in">to_i</span>(si, sj));<br>      <span class="hljs-comment">// cout &lt;&lt; &quot;end:&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span><br>      <span class="hljs-comment">// cout &lt;&lt; &quot;dis:&quot; &lt;&lt; d[to_i(i, j)] &lt;&lt; endl;</span><br>      ans = <span class="hljs-built_in">max</span>(ans, k * a[i][j] - d[<span class="hljs-built_in">to_i</span>(i, j)]);<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="法二-1">法二</h3><p>枚举走到终点的步数。利用dp找到指定步数下最大权值。可利用滚动数组优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>  <span class="hljs-type">int</span> si, sj;<br>  cin &gt;&gt; si &gt;&gt; sj;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>      cin &gt;&gt; a[i][j];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>      f[<span class="hljs-number">0</span>][i][j] = f[<span class="hljs-number">1</span>][i][j] = -linf;<br>    &#125;<br>  &#125;<br>  f[<span class="hljs-number">0</span>][si][sj] = <span class="hljs-number">0</span>;<br>  ll ans = k * a[si][sj];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt;= <span class="hljs-built_in">min</span>(k, <span class="hljs-number">1ll</span> * n * m); ++x) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">0</span>; t &lt; <span class="hljs-number">4</span>; ++t) &#123;<br>          <span class="hljs-type">int</span> cx = i + dx[t], cy = j + dy[t];<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(cx, cy)) f[x &amp; <span class="hljs-number">1</span>][i][j] = <span class="hljs-built_in">max</span>(f[(x - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">1</span>][cx][cy] + a[i][j], f[x &amp; <span class="hljs-number">1</span>][i][j]);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>        ans = <span class="hljs-built_in">max</span>(ans, f[x &amp; <span class="hljs-number">1</span>][i][j] + (k - x) * a[i][j]);<br>      &#125;<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="help-is-needed-for-dexter数学">14.Help is needed forDexter（数学）</h2><p>https://www.luogu.com.cn/problem/UVA11384</p><p>显然重复的元素越多越好。</p><p>注意到一种较优的做法是 <span class="math display">\[f_n=f_{\left\lfloor\frac{n}{2} \right\rfloor}+1\]</span> 先在来证明这是最优的。显然有<spanclass="math inline">\(f_n\)</span>是不减少的。</p><p>有<spanclass="math inline">\(f_n=\left\lfloor\log_2{n}\right\rfloor+1\)</span></p><p>若这不是最优的，则存在最小的<spanclass="math inline">\(m\)</span>使得 <span class="math display">\[f_m\leq \left\lfloor\log_2{m}\right\rfloor\]</span> 那么 <span class="math display">\[f_{m-1}=\left\lfloor\log_2{(m-1)}\right\rfloor+1\]</span> 而<span class="math inline">\(f_m\geq f_{m-1}\)</span>，故<span class="math display">\[m=2^k\]</span> 因此我们可以进行<spanclass="math inline">\(k\)</span>次操作让，<spanclass="math inline">\(2^k\)</span>个元素变成0，不妨设第<spanclass="math inline">\(i\)</span>次操作减去<spanclass="math inline">\(a_i\)</span>。</p><p>设<span class="math inline">\(S\)</span>为<spanclass="math inline">\(\{1,2,\cdots,k\}\)</span>的非空子集。那么就有对于<spanclass="math inline">\(1\leq x \leq 2^k\)</span> 存在一个<spanclass="math inline">\(S\)</span> 使得<spanclass="math inline">\(\sum_{i\in S} a_i=x\)</span>，但是只有<spanclass="math inline">\(2^k-1\)</span>个非空子集。不可能形成<spanclass="math inline">\(2^k\)</span>个元素。</p><p>故上式就是最优解。</p><h2 id="colored-cubes枚举">15.Colored Cubes（枚举）</h2><p>https://www.luogu.com.cn/problem/UVA1352</p><p>数据很小，考虑直接枚举。难点在于写代码。</p><p>可以先打表出一个正方体的所有情况，枚举每一个正方体的情况，第一个可以按照默认位置。然后记录每一面的各个颜色出现次数，保留最多的即可。</p><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REP(i, n) for (int i = 1; i &lt;= (n); ++i)</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pii;<br><span class="hljs-keyword">typedef</span> pair&lt;ll, ll&gt; pll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br><span class="hljs-comment">// using i128=__int128_t;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">9</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> iinf = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">const</span> ll linf = <span class="hljs-number">1e18</span>;<br><br><span class="hljs-type">int</span> pose[<span class="hljs-number">25</span>][<span class="hljs-number">7</span>] = &#123;<br>    &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>&#125;,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;<br>    vector&lt;array&lt;string, 10&gt;&gt; <span class="hljs-built_in">col</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">REP</span>(i, n) <span class="hljs-built_in">REP</span>(j, <span class="hljs-number">6</span>) cin &gt;&gt; col[i][j];<br>    <span class="hljs-type">int</span> ans = iinf;<br>    <span class="hljs-type">int</span> p[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">auto</span> count = [&amp;]() -&gt; <span class="hljs-type">int</span> &#123;<br>      map&lt;string, <span class="hljs-type">int</span>&gt; cnt[<span class="hljs-number">7</span>];<br>      <span class="hljs-built_in">REP</span>(i, <span class="hljs-number">6</span>) cnt[i][col[<span class="hljs-number">1</span>][i]]++;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-built_in">REP</span>(j, <span class="hljs-number">6</span>) cnt[j][col[i][pose[p[i]][j]]]++;<br>      &#125;<br>      <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>      <span class="hljs-built_in">REP</span>(i, <span class="hljs-number">6</span>) &#123;<br>        <span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = cnt[i].<span class="hljs-built_in">begin</span>(); it != cnt[i].<span class="hljs-built_in">end</span>(); ++it) mx = <span class="hljs-built_in">max</span>(mx, it-&gt;second);<br>        res += n - mx;<br>      &#125;<br>      <span class="hljs-keyword">return</span> res;<br>    &#125;;<br>    function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> id) -&gt; <span class="hljs-type">void</span> &#123;<br>      <span class="hljs-keyword">if</span> (id &gt; n) <span class="hljs-keyword">return</span> ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">count</span>()), <span class="hljs-built_in">void</span>();<br>      <span class="hljs-built_in">REP</span>(i, <span class="hljs-number">24</span>) &#123;<br>        p[id] = i;<br>        <span class="hljs-built_in">dfs</span>(id + <span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">2</span>);<br>    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">STDIO</span><span class="hljs-params">()</span> </span>&#123;<br>  ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">STDIO</span>();<br>  <span class="hljs-type">int</span> _ = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// cin&gt;&gt;_;</span><br>  <span class="hljs-keyword">while</span> (_--) <span class="hljs-built_in">solve</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="even-parity枚举">16.Even Parity（枚举）</h2><p>https://www.luogu.com.cn/problem/UVA11464</p><p>第一行一旦确定，所有的都确定了。枚举第一行的所有情形。检查是否满足条件即可。</p><p>难点还是写代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REP(i, n) for (int i = 1; i &lt;= (n); ++i)</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pii;<br><span class="hljs-keyword">typedef</span> pair&lt;ll, ll&gt; pll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br><span class="hljs-comment">// using i128=__int128_t;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">9</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> iinf = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">const</span> ll linf = <span class="hljs-number">1e18</span>;<br><span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin &gt;&gt; n;<br>  <span class="hljs-keyword">auto</span> check = [&amp;](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123; <span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">0</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt; <span class="hljs-number">0</span> &amp;&amp; y &lt;= n; &#125;;<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">a</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>));<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">c</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>));<br>  <span class="hljs-built_in">REP</span>(i, n) <span class="hljs-built_in">REP</span>(j, n) cin &gt;&gt; a[i][j];<br>  <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>, mi = iinf;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1ll</span> &lt;&lt; n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) b[j + <span class="hljs-number">1</span>] = i &gt;&gt; j &amp; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">bool</span> ok = <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n &amp;&amp; ok; ++j) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n &amp;&amp; ok; ++k) &#123;<br>        <span class="hljs-keyword">if</span> (b[k] == <span class="hljs-number">0</span> &amp;&amp; a[j][k] == <span class="hljs-number">1</span>) ok = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (b[k] == <span class="hljs-number">1</span> &amp;&amp; a[j][k] == <span class="hljs-number">0</span>) cnt++, c[j][k] = b[k];<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; ++k) &#123;<br>        <span class="hljs-type">int</span> C = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt; <span class="hljs-number">3</span>; ++l) &#123;<br>          <span class="hljs-type">int</span> cx = j + dx[l], cy = k + dy[l];<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(cx, cy) &amp;&amp; c[cx][cy]) C++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (C &amp; <span class="hljs-number">1</span>) &#123;<br>          b[k] = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          b[k] = <span class="hljs-number">0</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ok) mi = <span class="hljs-built_in">min</span>(mi, cnt);<br>    c = a;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (mi &lt; iinf) ans = mi;<br>  cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">STDIO</span><span class="hljs-params">()</span> </span>&#123;<br>  ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">STDIO</span>();<br>  <span class="hljs-type">int</span> _ = <span class="hljs-number">1</span>;<br>  cin &gt;&gt; _;<br>  <span class="hljs-built_in">REP</span>(i, _) cout &lt;&lt; <span class="hljs-string">&quot;Case &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>, <span class="hljs-built_in">solve</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="image-is-everything枚举">17.Image Is Everything(枚举)</h2><p>https://www.luogu.com.cn/problem/UVA1030</p><p>我们将一定没有的位置标记出来，即可算出答案。有以下两种情况。</p><ol type="1"><li>视图有<code>.</code>。</li><li>几个视图相互矛盾。</li></ol><p>难点依旧是写代码。具体实现看代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REP(i, n) for (int i = 1; i &lt;= (n); ++i)</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pii;<br><span class="hljs-keyword">typedef</span> pair&lt;ll, ll&gt; pll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br><span class="hljs-comment">// using i128=__int128_t;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">9</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> iinf = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">const</span> ll linf = <span class="hljs-number">1e18</span>;<br><br><span class="hljs-type">char</span> s[<span class="hljs-number">10</span>][<span class="hljs-number">15</span>][<span class="hljs-number">15</span>], h[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">T</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span>&amp; y, <span class="hljs-type">int</span>&amp; z)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x = l, y = k, z = j, <span class="hljs-built_in">void</span>();<br>  <span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> x = n + <span class="hljs-number">1</span> - k, y = l, z = j, <span class="hljs-built_in">void</span>();<br>  <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> x = n + <span class="hljs-number">1</span> - l, y = n + <span class="hljs-number">1</span> - k, z = j, <span class="hljs-built_in">void</span>();<br>  <span class="hljs-keyword">if</span> (i == <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> x = k, y = n + <span class="hljs-number">1</span> - l, z = j, <span class="hljs-built_in">void</span>();<br>  <span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span> x = n + <span class="hljs-number">1</span> - j, y = k, z = l, <span class="hljs-built_in">void</span>();<br>  <span class="hljs-keyword">if</span> (i == <span class="hljs-number">6</span>) <span class="hljs-keyword">return</span> x = j, y = k, z = n + <span class="hljs-number">1</span> - l, <span class="hljs-built_in">void</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;<br>    <span class="hljs-built_in">REP</span>(i, n) <span class="hljs-built_in">REP</span>(j, <span class="hljs-number">6</span>) <span class="hljs-built_in">REP</span>(k, n) cin &gt;&gt; s[j][i][k];<br>    <span class="hljs-built_in">REP</span>(i, n) <span class="hljs-built_in">REP</span>(j, n) <span class="hljs-built_in">REP</span>(k, n) h[i][j][k] = <span class="hljs-string">&#x27;?&#x27;</span>;<br>    <span class="hljs-built_in">REP</span>(i, <span class="hljs-number">6</span>) <span class="hljs-built_in">REP</span>(j, n) <span class="hljs-built_in">REP</span>(k, n) <span class="hljs-keyword">if</span> (s[i][j][k] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>      <span class="hljs-built_in">REP</span>(l, n) &#123;<br>        <span class="hljs-type">int</span> x, y, z;<br>        <span class="hljs-built_in">T</span>(i, j, k, l, x, y, z);<br>        h[x][y][z] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-type">bool</span> ok = <span class="hljs-literal">true</span>;<br>      <span class="hljs-built_in">REP</span>(i, <span class="hljs-number">6</span>) <span class="hljs-built_in">REP</span>(j, n) <span class="hljs-built_in">REP</span>(k, n) <span class="hljs-keyword">if</span> (s[i][j][k] != <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>        <span class="hljs-built_in">REP</span>(l, n) &#123;<br>          <span class="hljs-type">int</span> x, y, z;<br>          <span class="hljs-built_in">T</span>(i, j, k, l, x, y, z);<br>          <span class="hljs-keyword">if</span> (h[x][y][z] == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>          <span class="hljs-keyword">if</span> (h[x][y][z] == <span class="hljs-string">&#x27;?&#x27;</span>) &#123;<br>            h[x][y][z] = s[i][j][k];<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>          <span class="hljs-keyword">if</span> (h[x][y][z] == s[i][j][k]) <span class="hljs-keyword">break</span>;<br>          h[x][y][z] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>          ok = <span class="hljs-literal">false</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (ok) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">REP</span>(i, n) <span class="hljs-built_in">REP</span>(j, n) <span class="hljs-built_in">REP</span>(k, n) ans += (h[i][j][k] != <span class="hljs-string">&#x27;.&#x27;</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Maximum weight: &quot;</span> &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot; gram(s)\n&quot;</span>;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">STDIO</span><span class="hljs-params">()</span> </span>&#123;<br>  ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">STDIO</span>();<br>  <span class="hljs-type">int</span> _ = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// cin&gt;&gt;_;</span><br>  <span class="hljs-keyword">while</span> (_--) <span class="hljs-built_in">solve</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="a-different-task数学">18.A Different Task(数学)</h2><p>https://www.luogu.com.cn/problem/UVA10795</p><p>我们从大到小移动是最优的。下面给出证明。</p><p>我们考虑移动<spanclass="math inline">\(x\)</span>的前一步，若需要移动，那么我们需要将<spanclass="math inline">\(1,2,\cdots,x-1\)</span>全部移动到另外一个柱子上。不管是否先移动小的，此时完全一致。故从大到小移动一定不劣。</p><p>考虑最大的，如果在正确的柱子上，就不需要移动，并且可以直接删除。</p><p>另外注意到操作完全可逆。假设我们需要将<spanclass="math inline">\(k\)</span>，从1移动到2，那么我们先将<spanclass="math inline">\(1,2,\cdots,k-1\)</span>移动到3。将初始到这个状态需要的操作数，和最终状态到这个状态的操作数分别计算出来。相加即是答案。</p><p>具体地。我们有函数<code>f(st,k,g)</code>，为从状态<spanclass="math inline">\(st\)</span>，将<spanclass="math inline">\(1,2,\cdots,k\)</span>移动到<spanclass="math inline">\(g\)</span>需要的最少操作数。</p><p>那么答案为<code>f(s,k-1,6-s[k]-e[k])+f(e,k-1,6-s[k]-e[k])+1</code>。</p><p>下面考虑计算f</p><p>若<span class="math inline">\(k\)</span>就在<spanclass="math inline">\(g\)</span>，那么<code>f(st,k,g)=f(st,k-1,g)</code>，注意处理<spanclass="math inline">\(k=0\)</span>。</p><p>否则<code>f(st,k,g)=f(st,k-1,6-g-st[k])+2^&#123;k-1&#125;</code></p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REP(i, n) for (int i = 1; i &lt;= (n); ++i)</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pii;<br><span class="hljs-keyword">typedef</span> pair&lt;ll, ll&gt; pll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br><span class="hljs-comment">// using i128=__int128_t;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">9</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> iinf = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">const</span> ll linf = <span class="hljs-number">1e18</span>;<br><br><span class="hljs-function">ll <span class="hljs-title">f</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; st, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> g)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (st[k] == g) <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(st, k - <span class="hljs-number">1</span>, g);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(st, k - <span class="hljs-number">1</span>, <span class="hljs-number">6</span> - g - st[k]) + (<span class="hljs-number">1ll</span> &lt;&lt; k - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, _ = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Case &quot;</span> &lt;&lt; (++_) &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">e</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; s[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; e[i];<br>    ll ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; --i) &#123;<br>      <span class="hljs-keyword">if</span> (s[i] != e[i]) &#123;<br>        ans = <span class="hljs-built_in">f</span>(s, i - <span class="hljs-number">1</span>, <span class="hljs-number">6</span> - s[i] - e[i]) + <span class="hljs-built_in">f</span>(e, i - <span class="hljs-number">1</span>, <span class="hljs-number">6</span> - s[i] - e[i]) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">STDIO</span><span class="hljs-params">()</span> </span>&#123;<br>  ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">STDIO</span>();<br>  <span class="hljs-type">int</span> _ = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// cin&gt;&gt;_;</span><br>  <span class="hljs-keyword">while</span> (_--) <span class="hljs-built_in">solve</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h2 id="networkdfs贪心">19.Network(DFS,贪心)</h2><p>https://www.luogu.com.cn/problem/UVA315</p><p>以s为根。</p><p>有贪心策略，从最深节点开始遍历。走<spanclass="math inline">\(k\)</span>个父亲，然后从他开始dfs，标记离他小于k的。下面说明其正确性。</p><p>首先<spanclass="math inline">\(k\)</span>子树下全部标记了。同时，更靠近上面的节点。故一定不会更差。</p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REP(i, n) for (int i = 1; i &lt;= (n); ++i)</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pii;<br><span class="hljs-keyword">typedef</span> pair&lt;ll, ll&gt; pll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br><span class="hljs-comment">// using i128=__int128_t;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> iinf = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">const</span> ll linf = <span class="hljs-number">1e18</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; d[N], g[N];<br>bitset&lt;N&gt; vis;<br><span class="hljs-type">int</span> fa[N], n, s, k;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> pre, <span class="hljs-type">int</span> dep)</span> </span>&#123;<br>  fa[x] = pre;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> y : g[x]) &#123;<br>    <span class="hljs-keyword">if</span> (y == pre) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-built_in">dfs</span>(y, x, dep + <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (x != pre &amp;&amp; g[x].<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) d[dep].<span class="hljs-built_in">push_back</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> pre, <span class="hljs-type">int</span> dep)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (dep &gt; k) <span class="hljs-keyword">return</span>;<br>  vis[x] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> y : g[x]) &#123;<br>    <span class="hljs-keyword">if</span> (y == pre) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-built_in">dfs2</span>(y, x, dep + <span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  cin &gt;&gt; n &gt;&gt; s &gt;&gt; k;<br>  vis = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) g[i].<span class="hljs-built_in">clear</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) d[i].<span class="hljs-built_in">clear</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-type">int</span> x, y;<br>    cin &gt;&gt; x &gt;&gt; y;<br>    g[x].<span class="hljs-built_in">push_back</span>(y);<br>    g[y].<span class="hljs-built_in">push_back</span>(x);<br>  &#125;<br>  <span class="hljs-built_in">dfs</span>(s, s, <span class="hljs-number">0</span>);<br>  <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt; k; --i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> x : d[i]) &#123;<br>      <span class="hljs-keyword">if</span> (vis[x]) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-type">int</span> y = x;<br>      ans++;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; ++i) y = fa[y];<br>      <span class="hljs-built_in">dfs2</span>(y, y, <span class="hljs-number">0</span>);<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">STDIO</span><span class="hljs-params">()</span> </span>&#123;<br>  ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">STDIO</span>();<br>  <span class="hljs-type">int</span> _ = <span class="hljs-number">1</span>;<br>  cin &gt;&gt; _;<br>  <span class="hljs-keyword">while</span> (_--) <span class="hljs-built_in">solve</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="pie实数二分">20.Pie(实数二分)</h2><p>https://www.luogu.com.cn/problem/UVA12097</p><p>可用<code>const double Pi = acos(-1.0);</code>得到<spanclass="math inline">\(\pi\)</span>的值。</p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REP(i, n) for (int i = 1; i &lt;= (n); ++i)</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pii;<br><span class="hljs-keyword">typedef</span> pair&lt;ll, ll&gt; pll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br><span class="hljs-comment">// using i128=__int128_t;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">9</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> iinf = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">const</span> ll linf = <span class="hljs-number">1e18</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> Pi = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>);<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, f;<br>  cin &gt;&gt; n &gt;&gt; f;<br>  f++;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">r</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-built_in">REP</span>(i, n) cin &gt;&gt; r[i];<br>  <span class="hljs-keyword">auto</span> check = [&amp;](<span class="hljs-type">double</span> x) &#123;<br>    ll cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">REP</span>(i, n) &#123;<br>      <span class="hljs-type">double</span> S = Pi * r[i] * r[i];<br>      cnt += (ll)(S / x);<br>      <span class="hljs-keyword">if</span> (cnt &gt;= f) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;;<br>  <span class="hljs-type">double</span> L = <span class="hljs-number">0</span>, R = <span class="hljs-number">1e17</span>;<br>  <span class="hljs-keyword">while</span> (R - L &gt; <span class="hljs-number">1e-6</span>) &#123;<br>    <span class="hljs-type">double</span> mid = (R + L) / <span class="hljs-number">2.0</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) &#123;<br>      L = mid;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      R = mid;<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">6</span>) &lt;&lt; L &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">STDIO</span><span class="hljs-params">()</span> </span>&#123;<br>  ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">STDIO</span>();<br>  <span class="hljs-type">int</span> _ = <span class="hljs-number">1</span>;<br>  cin &gt;&gt; _;<br>  <span class="hljs-keyword">while</span> (_--) <span class="hljs-built_in">solve</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="beijing-guards贪心二分数学">21.BeijingGuards(贪心+二分/数学)</h2><p>https://www.luogu.com.cn/problem/UVA1335</p><h3 id="法一-2">法一</h3><p>假设有<spanclass="math inline">\(x\)</span>个礼物，如何才能避免相邻重复呢。一种策略是一个从前往后拿，一个从后往前拿。</p><p>当偶数个人时，显然奇数从前往后，偶数从后往前拿即可。</p><p>我们假设第一个人从前往后拿。那么第二个人应该尽量从后往前拿。所以我从第二个人开始从前往后拿，交替进行。</p><p>偶数正确性显然。</p><p>奇数时有，最后一个应尽可能从后往前拿，即少拿前面的，那么这要求前一个尽量拿前面的，这样递推下去，即证。</p><p>注意特判<code>n==0</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REP(i, n) for (int i = 1; i &lt;= (n); ++i)</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pii;<br><span class="hljs-keyword">typedef</span> pair&lt;ll, ll&gt; pll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br><span class="hljs-comment">// using i128=__int128_t;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">9</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> iinf = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">const</span> ll linf = <span class="hljs-number">1e18</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;<br>    <span class="hljs-comment">// d-&gt;[1,r1]</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">r</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">u</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">d</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; r[i];<br>    d[<span class="hljs-number">1</span>] = r[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">auto</span> check = [&amp;](<span class="hljs-type">int</span> x) &#123;<br>      <span class="hljs-keyword">if</span> (x &lt; r[<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-type">int</span> a = r[<span class="hljs-number">1</span>], b = x - r[<span class="hljs-number">1</span>];<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) u[i] = d[i] = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i &amp; <span class="hljs-number">1</span>) &#123;<br>          u[i] = <span class="hljs-built_in">min</span>(b - u[i - <span class="hljs-number">1</span>], r[i]);<br>          d[i] = <span class="hljs-built_in">min</span>(r[i] - u[i], a - d[i - <span class="hljs-number">1</span>]);<br>          <span class="hljs-keyword">if</span> (u[i] + d[i] &lt; r[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          d[i] = <span class="hljs-built_in">min</span>(r[i], a - d[i - <span class="hljs-number">1</span>]);<br>          u[i] = <span class="hljs-built_in">min</span>(b - u[i - <span class="hljs-number">1</span>], r[i] - d[i]);<br>          <span class="hljs-keyword">if</span> (u[i] + d[i] &lt; r[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> d[n] == <span class="hljs-number">0</span>;<br>    &#125;;<br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-type">int</span> ans = r[<span class="hljs-number">1</span>] + r[n];<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) ans = <span class="hljs-built_in">max</span>(ans, r[i] + r[i + <span class="hljs-number">1</span>]);<br>      cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>      cout &lt;&lt; r[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> L = <span class="hljs-number">0</span>, R = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-keyword">while</span> (L + <span class="hljs-number">1</span> != R) &#123;<br>      <span class="hljs-type">int</span> mid = L + R &gt;&gt; <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) &#123;<br>        R = mid;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        L = mid;<br>      &#125;<br>    &#125;<br>    cout &lt;&lt; R &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">STDIO</span><span class="hljs-params">()</span> </span>&#123;<br>  ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">STDIO</span>();<br>  <span class="hljs-type">int</span> _ = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// cin &gt;&gt; _;</span><br>  <span class="hljs-keyword">while</span> (_--) <span class="hljs-built_in">solve</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="法二-2">法二</h3><p>基于第一种方法的策略。如果你注意力再强一点。可以注意到：</p><p>答案为 <span class="math display">\[A=\max\left(\max_{i=1}^{n-1}(r_i+r_{i+1}),r_1+r_n, \left\lceil\frac{\sum r_i }{\lfloor \frac{n}{2} \rfloor} \right \rceil \right )\]</span> 重点是 <span class="math display">\[A\ge\left\lceil \frac{\sum r_i }{\lfloor \frac{n}{2} \rfloor} \right\rceil\quad\quad\quad (*)\]</span> 假设已经满足前面的式子。</p><blockquote><p>偶数显然，仅考虑奇数情形。</p></blockquote><p>我们证明满足要求的充要条件是（*）式。</p><p><strong>必要性</strong>：设有<spanclass="math inline">\(x\)</span>种，每一种最多被<spanclass="math inline">\(\lfloor \frac{n}{2} \rfloor\)</span>个人共有，于是 <span class="math display">\[x\left\lfloor \frac{n}{2} \right \rfloor\ge \sum r_i\]</span> <strong>充分性</strong>：由于对称性，我们可以<strong>假设<spanclass="math inline">\(r_1\)</span>最大</strong>。设<spanclass="math inline">\(f_i\)</span>为第<spanclass="math inline">\(i\)</span>个人的礼物与<spanclass="math inline">\(r_1\)</span>的交集。有递推关系：</p><p><span class="math inline">\(f_1=r_1,f_2=0\)</span> <spanclass="math display">\[f_{2k}=\min(r_{2k},r_1-f_{2k-1})\]</span></p><p><span class="math display">\[f_{2k+1}=\max(0,r_{2k}+r_{2k+1}+r_1-A-f_{2k})\]</span></p><p>若<span class="math inline">\(r_{2k}\le r_1-f_{2k-1}\)</span>：</p><p>那么有<span class="math inline">\(f_{2k}=r_{2k}\)</span>，将<spanclass="math inline">\(f_{2k+1}\)</span>带入<spanclass="math inline">\(f_{2k+2}\)</span>有： <spanclass="math display">\[\begin{aligned}f_{2k+2}&amp;=\min(r_{2k+2},\min(r_{1},A+f_{2k}-r_{2k}-r_{2k+1}))\\&amp;=\min(r_{2k+2},A-r_{2k+1})\\&amp;=r_{2k+2}\end{aligned}\]</span></p><blockquote><p>这说明，若<span class="math inline">\(f_{2k+2}\neqr_{2k+2}\)</span>，那么<span class="math inline">\(f_{2k}\neqr_{2k}\)</span>。</p></blockquote><p>否则：<spanclass="math inline">\(f_{2k}=r_1-f_{2k-1}\)</span>，带入有 <spanclass="math display">\[\begin{aligned}f_{2k+1}&amp;=\max(0,r_{2k}+r_{2k+1}+f_{2k-1}-A)\\&amp;=\max(0,r_{2k+1}+r_{2k}+\max(0,r_{2k-1}+r_{2k-2}+f_{2k-3}-A) -A)\\&amp;=\max(0,r_{2k+1}+r_{2k}-A,r_{2k+1}+r_{2k}+r_{2k-1}+r_{2k-2}+f_{2k-3}-2A)\\&amp;=\max(0,r_{2k+1}+r_{2k}+r_{2k-1}+r_{2k-2}+f_{2k-3}-2A)\end{aligned}\]</span> 一直递推下去，显然有 <span class="math display">\[f_{2k+1}=\max(0,\sum_{i=2}^{2k+1}+r_1-kA)\]</span> 不妨设<span class="math inline">\(n=2t+1\)</span>，</p><p>若<span class="math inline">\(f_{2t}=r_{2t}\)</span>，显然成立。</p><p>否则 <span class="math display">\[f_n=\max(0,\sum_{i=1}^{n}r_i-\left\lfloor \frac{n}{2} \right \rfloor A)=0\]</span> 证毕。</p><h3 id="法三">法三</h3><p>如果你没有那么强的注意力，并且没想到贪心策略。</p><p>我们可以设<span class="math inline">\(mx_i\)</span><spanclass="math inline">\(mi_i\)</span>分别为第<spanclass="math inline">\(i\)</span>个人礼物与第一个的最大，最小交集。显然有递推公式<span class="math display">\[mx_i=\min(r_i,r_{1}-mi_{i-1})\]</span></p><p><span class="math display">\[mi_i=\max(0,r_1+r_i+r_{i-1}-mx_{i-1}-A)\]</span></p><p>我们需要<spanclass="math inline">\(mi_n=0\)</span>，注意到满足单调性，二分即可。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REP(i, n) for (int i = 1; i &lt;= (n); ++i)</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pii;<br><span class="hljs-keyword">typedef</span> pair&lt;ll, ll&gt; pll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br><span class="hljs-comment">// using i128=__int128_t;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">9</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> iinf = <span class="hljs-number">1e9</span>;<br><span class="hljs-type">const</span> ll linf = <span class="hljs-number">1e18</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  <span class="hljs-keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;<br>    <span class="hljs-type">int</span> L = <span class="hljs-number">0</span>, R = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">r</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">mi</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">mx</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-built_in">REP</span>(i, n) cin &gt;&gt; r[i];<br>    mi[<span class="hljs-number">1</span>] = mx[<span class="hljs-number">1</span>] = r[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>      cout &lt;&lt; r[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-built_in">REP</span>(i, n) L = <span class="hljs-built_in">max</span>(L, r[i] + r[i % n + <span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">auto</span> check = [&amp;](<span class="hljs-type">int</span> x) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>        mx[i] = <span class="hljs-built_in">min</span>(r[i], r[<span class="hljs-number">1</span>] - mi[i - <span class="hljs-number">1</span>]);<br>        mi[i] = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, r[<span class="hljs-number">1</span>] + r[i] + r[i - <span class="hljs-number">1</span>] - mx[i - <span class="hljs-number">1</span>] - x);<br>      &#125;<br>      <span class="hljs-keyword">return</span> mi[n] == <span class="hljs-number">0</span>;<br>    &#125;;<br>    <span class="hljs-keyword">while</span> (L + <span class="hljs-number">1</span> != R) &#123;<br>      <span class="hljs-type">int</span> mid = L + R &gt;&gt; <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) &#123;<br>        R = mid;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        L = mid;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(L)) R = L;<br>    cout &lt;&lt; R &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">STDIO</span><span class="hljs-params">()</span> </span>&#123;<br>  ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">STDIO</span>();<br>  <span class="hljs-type">int</span> _ = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// cin &gt;&gt; _;</span><br>  <span class="hljs-keyword">while</span> (_--) <span class="hljs-built_in">solve</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="calculator-conundrumfloyd-判圈">22 .Calculator Conundrum(floyd判圈)</h2><p>https://www.luogu.com.cn/problem/UVA11549</p><p>用<code>set</code>，直接暴力显然可做。但空间复杂度过高。</p><p>事实上，我们知道一定会循环，于是利用Floyd判圈法即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, k;<br>  cin &gt;&gt; n &gt;&gt; k;<br>  <span class="hljs-keyword">auto</span> nex = [&amp;](<span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">int</span> &#123;<br>    ll res = <span class="hljs-number">1ll</span> * x * x;<br>    <span class="hljs-type">int</span> b[<span class="hljs-number">20</span>], h = <span class="hljs-number">0</span>, p;<br>    <span class="hljs-keyword">while</span> (res) b[++h] = res % <span class="hljs-number">10</span>, res /= <span class="hljs-number">10</span>;<br>    p = <span class="hljs-built_in">min</span>(h, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= p; ++i) res = res * <span class="hljs-number">10</span> + b[h--];<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;;<br>  <span class="hljs-type">int</span> p1 = k, p2 = k, ans = k;<br>  <span class="hljs-keyword">do</span> &#123;<br>    p1 = <span class="hljs-built_in">nex</span>(p1);<br>    p2 = <span class="hljs-built_in">nex</span>(p2), ans = <span class="hljs-built_in">max</span>(ans, p2);<br>    p2 = <span class="hljs-built_in">nex</span>(p2), ans = <span class="hljs-built_in">max</span>(ans, p2);<br>  &#125; <span class="hljs-keyword">while</span> (p1 != p2);<br>  cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="meteor扫描线">23.Meteor(扫描线)</h2><p>https://www.luogu.com.cn/problem/UVA1398</p><p>计算每个点在框里的时间。然后就比较典了。可以直接离散化线段树做。</p><p>但用扫描线更简单。下面是扫描线代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>  <span class="hljs-type">double</span> x;<br>  <span class="hljs-type">int</span> ty;<br>  <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node u) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> x == u.x ? ty &lt; u.ty : x &lt; u.x; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> h, w, n;<br>  cin &gt;&gt; w &gt;&gt; h &gt;&gt; n;<br>  <span class="hljs-keyword">auto</span> cal = [&amp;](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> e, <span class="hljs-type">double</span>&amp; L, <span class="hljs-type">double</span>&amp; R) &#123;<br>    <span class="hljs-keyword">if</span> (v == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">if</span> (x &lt;= <span class="hljs-number">0</span> || x &gt;= e) R = L - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v &gt; <span class="hljs-number">0</span>) &#123;<br>      L = <span class="hljs-built_in">max</span>(L, -(<span class="hljs-type">double</span>)(x) / v);<br>      R = <span class="hljs-built_in">min</span>(R, (<span class="hljs-type">double</span>)(e - x) / v);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      L = <span class="hljs-built_in">max</span>(L, (<span class="hljs-type">double</span>)(e - x) / v);<br>      R = <span class="hljs-built_in">min</span>(R, -(<span class="hljs-type">double</span>)(x) / v);<br>    &#125;<br>  &#125;;<br>  vector&lt;node&gt; e;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-type">int</span> x, y, a, b;<br>    cin &gt;&gt; x &gt;&gt; y &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-type">double</span> L = <span class="hljs-number">0</span>, R = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-built_in">cal</span>(x, a, w, L, R);<br>    <span class="hljs-built_in">cal</span>(y, b, h, L, R);<br>    <span class="hljs-keyword">if</span> (L &lt; R) &#123;<br>      e.<span class="hljs-built_in">push_back</span>(&#123;L, <span class="hljs-number">1</span>&#125;);<br>      e.<span class="hljs-built_in">push_back</span>(&#123;R, <span class="hljs-number">-1</span>&#125;);<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">sort</span>(e.<span class="hljs-built_in">begin</span>(), e.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, cur = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [x, y] : e) &#123;<br>    <span class="hljs-comment">// cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot;\n&quot;;</span><br>    cur += y;<br>    ans = <span class="hljs-built_in">max</span>(cur, ans);<br>  &#125;<br>  cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="city-game扫描线-dp">24.City Game（扫描线 dP）</h2><p>https://ac.nowcoder.com/acm/problem/51000</p><p>我们将连续的空格看成一条线，维护三个信息，<spanclass="math inline">\((i,j)\)</span>向上的最大高度，以及这个长度最多向左，右移动的位置。可以证明答案一定在这之中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[N][N], le[N][N], L[N][N], R[N][N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, m;<br>  cin &gt;&gt; n &gt;&gt; m;<br>  <span class="hljs-built_in">REP</span>(i, n) <span class="hljs-built_in">REP</span>(j, m) &#123;<br>    <span class="hljs-type">char</span> x;<br>    cin &gt;&gt; x;<br>    a[i][j] = (x == <span class="hljs-string">&#x27;F&#x27;</span>);<br>  &#125;<br>  <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (a[i][j]) &#123;<br>        le[i][j] = le[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>;<br>        L[i][j] = <span class="hljs-built_in">max</span>(p + <span class="hljs-number">1</span>, L[i - <span class="hljs-number">1</span>][j]);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        p = j;<br>      &#125;<br>    &#125;<br>    p = m + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= <span class="hljs-number">1</span>; --j) &#123;<br>      <span class="hljs-keyword">if</span> (a[i][j]) &#123;<br>        R[i][j] = <span class="hljs-built_in">min</span>(p - <span class="hljs-number">1</span>, R[i - <span class="hljs-number">1</span>][j] == <span class="hljs-number">0</span> ? m + <span class="hljs-number">1</span> : R[i - <span class="hljs-number">1</span>][j]);<br>        ans = <span class="hljs-built_in">max</span>(ans, le[i][j] * (R[i][j] - L[i][j] + <span class="hljs-number">1</span>));<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        p = j;<br>      &#125;<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; ans * <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="c2.-adjust-the-presentation-hard-version">25.C2. Adjust ThePresentation (Hard Version)</h2><p>https://codeforces.com/contest/2021/problem/C2</p><p>维护每个数在b首次出现的位置，需要满足第一个为1，且递增排序。我们改变一个值，只会形象左右两边的数。用map存一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, m, q;<br>  cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">10</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(m + <span class="hljs-number">10</span>)</span>, <span class="hljs-title">pos</span><span class="hljs-params">(n + <span class="hljs-number">10</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i], pos[a[i]] = i;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) cin &gt;&gt; b[i];<br>  <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>  vector&lt;set&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">st</span>(n + <span class="hljs-number">1</span>);<br>  map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; f;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) st[b[i]].<span class="hljs-built_in">insert</span>(i);<br>  <span class="hljs-keyword">auto</span> insert = [&amp;](<span class="hljs-type">int</span> i) &#123;<br>    <span class="hljs-keyword">auto</span> [it, y] = f.<span class="hljs-built_in">emplace</span>(i, b[i]);<br>    <span class="hljs-keyword">if</span> (!y) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">auto</span> r = <span class="hljs-built_in">next</span>(it);<br>    <span class="hljs-keyword">if</span> (r != f.<span class="hljs-built_in">end</span>()) cnt += (pos[b[i]] + <span class="hljs-number">1</span> != pos[r-&gt;second]);<br>    <span class="hljs-keyword">if</span> (it != f.<span class="hljs-built_in">begin</span>()) &#123;<br>      <span class="hljs-keyword">auto</span> l = <span class="hljs-built_in">prev</span>(it);<br>      cnt += (pos[b[i]] - <span class="hljs-number">1</span> != pos[l-&gt;second]);<br>      <span class="hljs-keyword">if</span> (r != f.<span class="hljs-built_in">end</span>()) &#123;<br>        cnt -= (pos[l-&gt;second] + <span class="hljs-number">1</span> != pos[r-&gt;second]);<br>      &#125;<br>    &#125;<br>  &#125;;<br>  <span class="hljs-keyword">auto</span> erase = [&amp;](<span class="hljs-type">int</span> i) &#123;<br>    <span class="hljs-keyword">auto</span> it = f.<span class="hljs-built_in">find</span>(i);<br>    <span class="hljs-keyword">if</span> (it == f.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">auto</span> r = <span class="hljs-built_in">next</span>(it);<br>    <span class="hljs-keyword">if</span> (r != f.<span class="hljs-built_in">end</span>()) cnt -= (pos[b[i]] + <span class="hljs-number">1</span> != pos[r-&gt;second]);<br>    <span class="hljs-keyword">if</span> (it != f.<span class="hljs-built_in">begin</span>()) &#123;<br>      <span class="hljs-keyword">auto</span> l = <span class="hljs-built_in">prev</span>(it);<br>      cnt -= (pos[b[i]] - <span class="hljs-number">1</span> != pos[l-&gt;second]);<br>      <span class="hljs-keyword">if</span> (r != f.<span class="hljs-built_in">end</span>()) &#123;<br>        cnt += (pos[l-&gt;second] + <span class="hljs-number">1</span> != pos[r-&gt;second]);<br>      &#125;<br>    &#125;<br>    f.<span class="hljs-built_in">erase</span>(it);<br>  &#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (st[i].<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">insert</span>(*st[i].<span class="hljs-built_in">begin</span>());<br>  &#125;<br>  <span class="hljs-keyword">if</span> (cnt || f.<span class="hljs-built_in">begin</span>()-&gt;second != a[<span class="hljs-number">1</span>]) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;TIDAK\n&quot;</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;YA\n&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; ++i) &#123;<br>    <span class="hljs-type">int</span> x, t;<br>    cin &gt;&gt; x &gt;&gt; t;<br>    <span class="hljs-keyword">if</span> (b[x] != t) &#123;<br>      st[b[x]].<span class="hljs-built_in">erase</span>(x);<br>      <span class="hljs-built_in">erase</span>(x);<br>      <span class="hljs-keyword">if</span> (st[b[x]].<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">insert</span>(*st[b[x]].<span class="hljs-built_in">begin</span>());<br>      <span class="hljs-keyword">if</span> (st[t].<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">erase</span>(*st[t].<span class="hljs-built_in">begin</span>());<br>      b[x] = t;<br>      st[t].<span class="hljs-built_in">insert</span>(x);<br>      <span class="hljs-built_in">insert</span>(*st[t].<span class="hljs-built_in">begin</span>());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cnt || f.<span class="hljs-built_in">begin</span>()-&gt;second != a[<span class="hljs-number">1</span>]) &#123;<br>      cout &lt;&lt; <span class="hljs-string">&quot;TIDAK\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      cout &lt;&lt; <span class="hljs-string">&quot;YA\n&quot;</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="team-division">26.<strong>3 Team Division</strong></h2><p>https://atcoder.jp/contests/abc375/tasks/abc375_e</p><p>DP</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> f[<span class="hljs-number">110</span>][<span class="hljs-number">510</span>][<span class="hljs-number">510</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, ex = <span class="hljs-number">0</span>;<br>  cin &gt;&gt; n;<br>  <span class="hljs-function">vector&lt;pii&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    cin &gt;&gt; a[i].first &gt;&gt; a[i].second;<br>    ex += a[i].second;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (ex % <span class="hljs-number">3</span>) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  ex /= <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= ex; ++j) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= ex; ++k) &#123;<br>        f[i][j][k] = iinf;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// f[i][j][k], 到i，1有j，2有k，的最小次数。</span><br>  f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    sum += a[i].second;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt;= ex; ++x) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt;= ex; ++y) &#123;<br>        <span class="hljs-type">int</span> z = sum - x - y;<br>        <span class="hljs-keyword">if</span> (z &gt; ex || z &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (y &gt;= a[i].second) f[i][x][y] = <span class="hljs-built_in">min</span>(f[i][x][y], f[i - <span class="hljs-number">1</span>][x][y - a[i].second] + (a[i].first != <span class="hljs-number">2</span>));<br>        <span class="hljs-keyword">if</span> (x &gt;= a[i].second) f[i][x][y] = <span class="hljs-built_in">min</span>(f[i][x][y], f[i - <span class="hljs-number">1</span>][x - a[i].second][y] + (a[i].first != <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">if</span> (z &gt;= a[i].second) f[i][x][y] = <span class="hljs-built_in">min</span>(f[i][x][y], f[i - <span class="hljs-number">1</span>][x][y] + (a[i].first != <span class="hljs-number">3</span>));<br>      &#125;<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; (f[n][ex][ex] &gt; n ? <span class="hljs-number">-1</span> : f[n][ex][ex]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="c.-alya-and-permutation">27.C. Alya and Permutation</h2><p>https://codeforces.com/contest/2035/problem/C</p><p>贪心</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lb</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123; <span class="hljs-keyword">return</span> n &amp; (-n); &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin &gt;&gt; n;<br>  <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">//.....1&amp;3|n-1&amp;n</span><br>    cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span> || i == <span class="hljs-number">3</span> || i == n - <span class="hljs-number">1</span> || i == n) <span class="hljs-keyword">continue</span>;<br>      cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-number">3</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; n - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-type">int</span> h = n, cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (h &gt; <span class="hljs-number">1</span>) &#123;<br>      h &gt;&gt;= <span class="hljs-number">1</span>;<br>      cnt &lt;&lt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    h *= cnt;<br>    cout &lt;&lt; <span class="hljs-number">2</span> * h - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (n == h) &#123;<br>      <span class="hljs-comment">// 3&amp;1|n-2&amp;n-1|n</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span> || i == <span class="hljs-number">3</span> || i == n - <span class="hljs-number">2</span> || i == n - <span class="hljs-number">1</span> || i == n) <span class="hljs-keyword">continue</span>;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>      &#125;<br>      cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-number">3</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; n - <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; n - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 6</span><br>      <span class="hljs-comment">// |n-1&amp;1|h-2&amp;h-1|h</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i == n - <span class="hljs-number">1</span> || i == <span class="hljs-number">1</span> || i == h - <span class="hljs-number">2</span> || i == h - <span class="hljs-number">1</span> || i == h) <span class="hljs-keyword">continue</span>;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>      &#125;<br>      cout &lt;&lt; n - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; h - <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; h - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; h &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="d.-yet-another-real-number-problem">28.D. Yet Another RealNumber Problem</h2><p>https://codeforces.com/contest/2035/problem/D</p><p>单调栈，贪心</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin &gt;&gt; n;<br>  vector&lt;pll&gt; stk;<br>  ll sum = <span class="hljs-number">0</span>, a, r;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    ll cnt = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; a;<br>    <span class="hljs-keyword">while</span> (a % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>      a &gt;&gt;= <span class="hljs-number">1</span>;<br>      cnt++;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (stk.<span class="hljs-built_in">size</span>() &amp;&amp; (cnt &gt;= <span class="hljs-number">30</span> || stk.<span class="hljs-built_in">back</span>().first &lt;= (a &lt;&lt; cnt))) &#123;<br>      sum += stk.<span class="hljs-built_in">back</span>().first;<br>      cnt += stk.<span class="hljs-built_in">back</span>().second;<br>      stk.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cnt) &#123;<br>      stk.<span class="hljs-built_in">push_back</span>(&#123;a, cnt&#125;);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      sum += a;<br>    &#125;<br>    ll ans = sum % mod;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [x, y] : stk) ans = (ans + <span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>, y, mod) * x % mod) % mod;<br>    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>  &#125;<br>  cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="e---sensor-optimization-dilemma-2">29.<strong>E - SensorOptimization Dilemma 2</strong></h2><p>https://atcoder.jp/contests/abc374/tasks/abc374_e</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  ll n, m;<br>  cin &gt;&gt; n &gt;&gt; m;<br>  <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">p</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">q</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    cin &gt;&gt; a[i] &gt;&gt; p[i] &gt;&gt; b[i] &gt;&gt; q[i];<br>    <span class="hljs-keyword">if</span> (b[i] * p[i] &gt; a[i] * q[i]) &#123;<br>      <span class="hljs-built_in">swap</span>(a[i], b[i]), <span class="hljs-built_in">swap</span>(p[i], q[i]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">auto</span> check = [&amp;](ll x) &#123;<br>    ll sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>      <span class="hljs-comment">// ll t = a[i] * b[i];</span><br>      <span class="hljs-comment">// ll k = x / t, r = x % t;</span><br>      <span class="hljs-comment">// sum += k * b[i] * p[i];</span><br>      ll cnt = <span class="hljs-number">4e18</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= b[i]; ++j) cnt = <span class="hljs-built_in">min</span>(cnt, j * <span class="hljs-number">1ll</span> * p[i] + ((<span class="hljs-built_in">max</span>(<span class="hljs-number">0ll</span>, x - j * a[i]) + b[i] - <span class="hljs-number">1</span>) / b[i]) * q[i]);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= a[i]; ++j) cnt = <span class="hljs-built_in">min</span>(cnt, j * <span class="hljs-number">1ll</span> * q[i] + ((<span class="hljs-built_in">max</span>(<span class="hljs-number">0ll</span>, x - j * b[i]) + a[i] - <span class="hljs-number">1</span>) / a[i]) * p[i]);<br>      sum += cnt;<br>      <span class="hljs-keyword">if</span> (sum &gt; m) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum &lt;= m;<br>  &#125;;<br>  ll L = <span class="hljs-number">0</span>, R = <span class="hljs-number">1e9</span> + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (L + <span class="hljs-number">1</span> != R) &#123;<br>    ll mid = L + R &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) &#123;<br>      L = mid;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      R = mid;<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; L &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="d.-penchick-and-desert-rabbit">30.D. Penchick and DesertRabbit</h2><p>https://codeforces.com/contest/2031/problem/D</p><h2 id="d.-cool-graph构造">31.D. Cool Graph(构造)</h2><p>https://codeforces.com/problemset/problem/2029/D</p><p>肯定是变成一颗树简单一点。注意到如果每一个连通块只有1个或2个点，就很简单了。</p><p>对一个点度数大于1进行操作。将其度数减小到1或0。</p><h2 id="e.-coloring-game二分图构造">32.E. ColoringGame（二分图，构造）</h2><p>https://codeforces.com/problemset/problem/1991/E</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; g[N];<br><span class="hljs-type">int</span> col[N];<br><span class="hljs-comment">// 二分图判定</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; y : g[x]) &#123;<br>    <span class="hljs-keyword">if</span> (col[y] == col[x]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (col[y] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>    col[y] = col[x] ^ <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(y)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n, m;<br>  cin &gt;&gt; n &gt;&gt; m;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) g[i].<span class="hljs-built_in">clear</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>    <span class="hljs-type">int</span> x, y;<br>    cin &gt;&gt; x &gt;&gt; y;<br>    g[x].<span class="hljs-built_in">push_back</span>(y);<br>    g[y].<span class="hljs-built_in">push_back</span>(x);<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) col[i] = <span class="hljs-number">-1</span>;<br>  col[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>)) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Alice&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>      cout &lt;&lt; <span class="hljs-string">&quot;1 2&quot;</span> &lt;&lt; endl;<br>      <span class="hljs-type">int</span> x, y;<br>      cin &gt;&gt; x &gt;&gt; y;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  vector&lt;<span class="hljs-type">int</span>&gt; col1, col2;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (col[i]) &#123;<br>      col<span class="hljs-number">2.</span><span class="hljs-built_in">push_back</span>(i);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      col<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; <span class="hljs-string">&quot;Bob&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-keyword">while</span> (col<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() || col<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>()) &#123;<br>    <span class="hljs-type">int</span> x, y;<br>    cin &gt;&gt; x &gt;&gt; y;<br>    <span class="hljs-keyword">if</span> (x &gt; y) <span class="hljs-built_in">swap</span>(x, y);<br>    <span class="hljs-keyword">if</span> (col<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &amp;&amp; x == <span class="hljs-number">1</span>) &#123;<br>      cout &lt;&lt; col<span class="hljs-number">1.</span><span class="hljs-built_in">back</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>      col<span class="hljs-number">1.</span><span class="hljs-built_in">pop_back</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (col<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() &amp;&amp; (x == <span class="hljs-number">2</span> || y == <span class="hljs-number">2</span>)) &#123;<br>      cout &lt;&lt; col<span class="hljs-number">2.</span><span class="hljs-built_in">back</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-number">2</span> &lt;&lt; endl;<br>      col<span class="hljs-number">2.</span><span class="hljs-built_in">pop_back</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (col<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>()) &#123;<br>        cout &lt;&lt; col<span class="hljs-number">1.</span><span class="hljs-built_in">back</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-number">3</span> &lt;&lt; endl;<br>        col<span class="hljs-number">1.</span><span class="hljs-built_in">pop_back</span>();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; col<span class="hljs-number">2.</span><span class="hljs-built_in">back</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-number">3</span> &lt;&lt; endl;<br>        col<span class="hljs-number">2.</span><span class="hljs-built_in">pop_back</span>();<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="p1453-城市环路基环树dp">33.P1453 城市环路（基环树，DP）</h2><p>https://www.luogu.com.cn/problem/P1453</p>]]></content>
    
    
    
    <tags>
      
      <tag>ACM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5thCombinatorics7</title>
    <link href="/2024/10/01/5thCombinatorics7/"/>
    <url>/2024/10/01/5thCombinatorics7/</url>
    
    <content type="html"><![CDATA[<h1 id="递推关系和生成函数">递推关系和生成函数</h1><h2 id="section">1</h2><blockquote><figure><img src="/images/image-20240909140350501.png"alt="image-20240909140350501" /><figcaption aria-hidden="true">image-20240909140350501</figcaption></figure></blockquote><h3 id="d">d</h3><p><span class="math display">\[\begin{aligned}\sum_{i=0}^{n} f_i^2&amp;=f_0^2+\sum_{i=1}^{n}f_i^2\\&amp;=f_0f_1+\left(f_1(f_2-f_0)+f_2(f_3-f_1)+\cdots+f_n(f_{n+1}-f_{n-1})\right)\\&amp;=f_nf_{n+1}\end{aligned}\]</span></p><h2 id="section-1">2</h2><blockquote><figure><img src="/images/image-20240909140828646.png"alt="image-20240909140828646" /><figcaption aria-hidden="true">image-20240909140828646</figcaption></figure></blockquote><p>容易想到证明<spanclass="math inline">\(f_n\)</span>与上式差值绝对值小于<spanclass="math inline">\(\frac{1}{2}\)</span> <span class="math display">\[\begin{aligned}\left |f_n-\frac{1}{\sqrt{5}} {\left( \frac{1+\sqrt{5}}{2} \right)^n}\right|&amp;=\left|\frac{1}{\sqrt{5}} {\left( \frac{1-\sqrt{5}}{2}\right)}^n \right| \\&amp;=\frac{1}{\sqrt{5}}\left(\frac{2}{\left(1+\sqrt{5} \right)}\right)^n\\&amp;&lt;\frac{1}{\sqrt{5}}\\&amp;&lt;\frac{1}{2}\end{aligned}\]</span></p><h2 id="section-2">3</h2><blockquote><figure><img src="/images/image-20240909141704032.png"alt="image-20240909141704032" /><figcaption aria-hidden="true">image-20240909141704032</figcaption></figure></blockquote><h3 id="b">b</h3><p><span class="math display">\[f_n=3f_{n-3}+2f_{n-4}\equiv 2f_{n-4} \mod{3}\]</span></p><p>因此 <span class="math display">\[3|f_n\iff 3|f_{n-4}\]</span></p><h3 id="c">c</h3><p>我们对斐波拉契数列 取模有 <span class="math display">\[0,1,1,2,3,1,0,1,\cdots\]</span> 发现其以<span class="math inline">\(6\)</span>为周期循环。</p><h2 id="section-3">6</h2><blockquote><figure><img src="/images/image-20240910155854537.png"alt="image-20240910155854537" /><figcaption aria-hidden="true">image-20240910155854537</figcaption></figure></blockquote><p>我们令 <span class="math display">\[f_n=a_xf_{n-x}+b_xf_{n-x-1}\]</span> 显然有 <span class="math display">\[b_n=a_{n-1}\]</span> 且 <span class="math display">\[a_n=a_{n-1}+b_{n-1}=a_{n-1}+a_{n-2}\Rightarrow b_n=b_{n-1}+b_{n-2}\]</span></p><p>又<span class="math inline">\(b_0=0,b_1=1\)</span>故<spanclass="math inline">\(b\)</span>是斐波拉契数列。</p><p>那么有 <span class="math display">\[f_n=f_{x+1}f_{n-x}+f_xf_{n-x-1}\]</span> 设<spanclass="math inline">\(n=km\)</span>，用数学归纳法即可。</p><h2 id="section-4">7</h2><blockquote><figure><img src="/images/image-20240910160533931.png"alt="image-20240910160533931" /><figcaption aria-hidden="true">image-20240910160533931</figcaption></figure></blockquote><p>设<span class="math inline">\(n=km+r\)</span> ，</p><p>那么有 <span class="math display">\[f_n=f_{r+1}f_{km}+f_rf_{km-1}\]</span> 注意到 <span class="math display">\[\gcd(f_n,f_{n+1}) =1\]</span> 我们有 <span class="math display">\[f_{km-1}=f_mf_{(k-1)m}+f_{m-1}f_{(k-1)m-1}\]</span></p><p>从而有 <span class="math display">\[\gcd(f_{km-1},f_m)=\gcd(f_m,f_{m-1})=1\]</span> 故 <span class="math display">\[\gcd(f_n,f_m)=\gcd(f_m,f_r)\]</span> 然后令n=m，m=r。类比欧几里得算法。可得 <spanclass="math display">\[\gcd(f_n,f_m)=f_{\gcd(n,m)}\]</span></p><h2 id="section-5">9</h2><blockquote><figure><img src="/images/image-20240910165450019.png"alt="image-20240910165450019" /><figcaption aria-hidden="true">image-20240910165450019</figcaption></figure></blockquote><p>有 <span class="math display">\[h_n=2(h_{n-1}+h_{n-2})\]</span> 特征方程<span class="math inline">\(x^2-2x-2=0\)</span>的根为<span class="math display">\[x=1\pm\sqrt{3}\]</span> 初值为<span class="math inline">\(h_0=1,h_1=3\)</span></p><p>带入得 <span class="math display">\[\begin{cases}c_1+c_2=1\\c_1(1+\sqrt{3})+c_2(1-\sqrt{3})=3\end{cases}\]</span> 解得 <span class="math display">\[c_1=\frac{3+2\sqrt{3}}{6}(1+\sqrt{3})^n+\frac{3-2\sqrt{3}}{6}(1-\sqrt{3})^n\]</span></p><h2 id="section-6">15</h2><blockquote><figure><img src="/images/image-20240910170155353.png"alt="image-20240910170155353" /><figcaption aria-hidden="true">image-20240910170155353</figcaption></figure></blockquote><p>有 <span class="math display">\[\frac{1}{1-x}=\sum_{n=0}^{\infty}x^n\]</span> 同时微分并乘<span class="math inline">\(x\)</span> <spanclass="math display">\[\frac{x}{(1-x)^2}=\sum_{n=0}^{\infty}nx^n\]</span> 同时微分并乘<span class="math inline">\(x\)</span> <spanclass="math display">\[\frac{x-x^3}{(1-x)^4}=\sum_{n=0}^{\infty}n^2x^n\]</span> 同时微分并乘<span class="math inline">\(x\)</span> <spanclass="math display">\[\frac{x^3+4x^2+x}{(1-x)^4}=\sum_{n=0}^{\infty}n^3x^n\]</span> 或者由 <span class="math display">\[n^3 = 6 \binom{n}{3} + 6 \binom{n}{2} + \binom{n}{1}\]</span> 得 <span class="math display">\[\begin{aligned}g(x)&amp;=\sum_{n=0}^{\infty}6\binom{n}{3}x^n+\sum_{n=0}^{\infty}6\binom{n}{2}x^n+\sum_{n=0}^{\infty} \binom{n}{1}x^n\\&amp;=6x^3\sum_{n=0}^{\infty}\binom{n+3}{n}x^n+6x^2\sum_{n=0}^{\infty}\binom{n+2}{n}x^n+x\sum_{n=0}^{\infty}\binom{n+1}{n}x^n\\&amp;=\frac{6x^3}{(1-x)^4}+\frac{6x^2}{(1-x)^3}+\frac{x}{(1-x)^2}\\&amp;=\frac{x^3+4x^2+x}{(1-x)^4}\end{aligned}\]</span></p><h2 id="section-7">21</h2><blockquote><figure><img src="/images/image-20240911135029474.png"alt="image-20240911135029474" /><figcaption aria-hidden="true">image-20240911135029474</figcaption></figure></blockquote><p>设该<span class="math inline">\(n+2\)</span>边形其中一个顶点为<spanclass="math inline">\(v\)</span>，我们连接其左右两个顶点后形成一个<spanclass="math inline">\(n+1\)</span>边形。然后设其连出去的<spanclass="math inline">\(n-1\)</span>条对角线分别产生<spanclass="math inline">\(k_i\)</span>个交点。那么将新产生<spanclass="math inline">\(k_i+1\)</span>个区域。因此答案为 <spanclass="math display">\[h_n=h_{n-1}+1+\sum_{i=1}^{n-1}(k_i+1)=h_{n-1}+n+\sum_{i=1}^{n-1}k_i\]</span> 而事实上<span class="math inline">\(k_i\)</span>的和就是<spanclass="math inline">\(n+2\)</span>边形的对角线产生的非顶点的交点数与<spanclass="math inline">\(n+1\)</span>边形的差。</p><p><strong>引理</strong>：而对于一个<spanclass="math inline">\(n\)</span>边形不考虑共点和顶点的情况下，将产生<spanclass="math inline">\(\binom{n}{4}\)</span>的交点。</p><p><strong>证明：</strong>对于四个顶点，我们连完对角线将产生一个交点，而任意一个交点，将对应四个顶点。因此交点数和从<spanclass="math inline">\(n\)</span>个顶点选出4个点是一一对应的。证毕。</p><p>故上式等于 <span class="math display">\[\begin{aligned}h_n&amp;=h_{n-1}+n+\sum_{i=1}^{n-1}k_i\\&amp;=h_{n-1}+\binom{n+2}{4}-\binom{n+1}{4}+n\\&amp;=h_{n-1}+\binom{n+1}{3}+n\end{aligned}\]</span> 有 <span class="math display">\[\begin{aligned}(1-x)g(x)&amp;=h_0+\sum_{n=1}^{\infty}\left(\binom{n+1}{3}+n\right)x^{n}\\&amp;=\sum_{n=1}^{\infty}\binom{n+1}{3}x^n+\sum_{n=1}^{\infty}nx^n\\&amp;=x^2\sum_{n=0}^{\infty}\binom{n+3}{3}x^n+\sum_{n=0}^{\infty} nx^n\\&amp;=\frac{x^2}{(1-x)^4}+\frac{x}{(1-x)^2}\\\end{aligned}\]</span> 从而 <span class="math display">\[\begin{aligned}g(x)&amp;=\frac{x^2}{(1-x)^5}+\frac{x}{(1-x)^3}\\&amp;=x^2\sum_{n=0}^{\infty}\binom{n+4}{n}x^n+x\sum_{n=0}^{\infty}\binom{n+2}{n}x^n\\&amp;=\sum_{n=0}^{\infty}\binom{n+2}{4}x^n+\sum_{n=0}^{\infty}\binom{n+1}{2}x^n\\&amp;=\sum_{n=0}^{\infty}\left(\binom{n+2}{4}+\binom{n+1}{2} \right)x^n\end{aligned}\]</span> 综上 <span class="math display">\[h_n=\binom{n+2}{4}+\binom{n+1}{2}\]</span> 或者考虑迭代法</p><h2 id="section-8">25</h2><blockquote><figure><img src="/images/image-20240914213455922.png"alt="image-20240914213455922" /><figcaption aria-hidden="true">image-20240914213455922</figcaption></figure></blockquote><p>使用生成函数： <span class="math display">\[\begin{aligned}g(x)&amp;=\left(\sum_{n=0}^{\infty}\frac{x^n}{n!}\right)^2\left(1+\frac{x^2}{2!}+\cdots\right)\left(x+\frac{x^3}{3!}+\cdots \right)\\&amp;=e^{2x}\left(\frac{e^x+e^{-x}}{2} \right) \left(\frac{e^x-e^{-x}}{2} \right)\\&amp;=\frac{e^{4x}-1}{4}\\&amp;=\frac{1}{4}\sum_{n=0}^{\infty} 4^{n} \frac{x^n}{n!}-\frac{1}{4}\\&amp;=\sum_{n=1}^{\infty} 4^{n-1} \frac{x^n}{n!}\end{aligned}\]</span> 故 <span class="math display">\[h_n=4^{n-1}(n\geq 1)\]</span> 特别地：<span class="math inline">\(h_0=1\)</span></p><h2 id="section-9">29</h2><blockquote><figure><img src="/images/image-20240920143718421.png"alt="image-20240920143718421" /><figcaption aria-hidden="true">image-20240920143718421</figcaption></figure></blockquote><p>设<span class="math inline">\(a_n\)</span>为<spanclass="math inline">\(1,3\)</span>均出现奇数次时的数，且<spanclass="math inline">\(b_n\)</span>为一奇一偶。</p><p>那么有 <span class="math display">\[\begin{cases}a_n=3a_{n-1}+2b_{n-1}\\b_n=3b_{n-1}+a_{n-1}+h_{n-1}\\h_n=3h_{n-1}+2b_{n-1}\\a_n+2b_n+h_n=5^n\end{cases}\]</span> 消元可得到<span class="math inline">\(h_n\)</span>的递推式<span class="math display">\[h_n-4h_{n-1}+3h_{n-2}=2\cdot5^{n-2}\]</span> 其齐次递推式的特征方程为 <span class="math display">\[x^2-4x+3=0\]</span> 从而求出解 <span class="math display">\[H_n=c_13^n+c_2\]</span> 下面求一个特解，设<spanclass="math inline">\(h_n=p5^n\)</span>，解得<spanclass="math inline">\(p=\frac{1}{4}\)</span>。</p><p>那么 <span class="math display">\[h_n=c_13^n+c_2+\frac{5^n}{4}\]</span> 带入<span class="math inline">\(h_0,h_1\)</span>得 <spanclass="math display">\[h_n=\frac{2\cdot 3^n+1+5^n}{4}\]</span> 或者根据递推式，利用生成函数： <span class="math display">\[\begin{aligned}(1-4x+3x^2)g(x)&amp;=1-x+\sum_{n=2}^{\infty}2\cdot5^{n-2}x^n\\&amp;=1-x+2x^2\sum_{n=0}^{\infty}(5x)^n\\&amp;=1-x+\frac{2x^2}{1-5x}\end{aligned}\]</span> 那么 <span class="math display">\[\begin{aligned}g(x)&amp;=\frac{1-x}{1-4x+3x^2}+\frac{2x^2}{(1-5x)(1-4x+3x^2)}\\&amp;=\frac{1}{1-3x}+\frac{\frac{1}{4}}{1-5x}-\frac{\frac{1}{2}}{1-3x}+\frac{\frac{1}{4}}{1-x}\\&amp;=\frac{1}{2}\sum_{n=0}^{\infty}3^nx^n+\frac{1}{4}\sum_{n=0}^{\infty}5^nx^n+\frac{1}{4}\sum_{n=0}^{\infty}x^n\\&amp;=\sum_{n=0}^{\infty}\left(\frac{5^n+2\cdot3^n+1}{4} \right)x^n\end{aligned}\]</span> 故 <span class="math display">\[h_n=\frac{5^n+2\cdot3^n+1}{4}\]</span></p><h2 id="section-10">37</h2><blockquote><figure><img src="/images/image-20240924154940086.png"alt="image-20240924154940086" /><figcaption aria-hidden="true">image-20240924154940086</figcaption></figure></blockquote><p>为了计算<spanclass="math inline">\(a_n\)</span>我们不妨将其分成以<spanclass="math inline">\(22\)</span>开头的和其他，若以<spanclass="math inline">\(22\)</span>开头显然有<spanclass="math inline">\(a_{n-2}\)</span> 种，否则我们再将<spanclass="math inline">\(a_{n-1}\)</span>分成三类，开头为<spanclass="math inline">\(0,1,2\)</span></p><p>设其分别有<span class="math inline">\(x,y,z\)</span>种。</p><p>那么有 <span class="math display">\[a_n=(y+z)+(x+z)+(x+y)+a_{n-2}=2a_{n-1}+a_{n-2}\]</span></p><h2 id="section-11">41</h2><blockquote><figure><img src="/images/image-20240924154950797.png"alt="image-20240924154950797" /><figcaption aria-hidden="true">image-20240924154950797</figcaption></figure></blockquote><p>我们不妨对这<spanclass="math inline">\(2n\)</span>个点编号，若我们先连接<spanclass="math inline">\(1,x\)</span>，显然<spanclass="math inline">\(2|x\)</span>，且满足递推式 <spanclass="math display">\[h_n=\sum_{k=1}^{n}h_{k-1}h_{n-k}\]</span> 为卡特兰序列。</p><p>故 <span class="math display">\[h_n=\frac{1}{n+1} \binom{2n}{n}\]</span></p><h2 id="section-12">49</h2><blockquote><figure><img src="/images/image-20240929111735871.png"alt="image-20240929111735871" /><figcaption aria-hidden="true">image-20240929111735871</figcaption></figure></blockquote><p><strong>公式似乎有错</strong>，应该是 <span class="math display">\[(x+y)(x+qy)\cdots(x+q^{m-1}y)=\sum_{k=0}^{n}q^{\binom{k}{2}}\binom{n}{k}_qx^{n-k}y^k\]</span></p><p>注意到： <span class="math display">\[\binom{n}{k}_q=\prod_{i=1}^{k}\frac{1-q^{n-k+i}}{1-q^i}\]</span> 因此： <span class="math display">\[\binom{n}{k}_q=\frac{1-q^n}{1-q^{n-k}}\binom{n-1}{k}_q\\\binom{n}{k}_q=\frac{1-q^n}{1-q^k}\binom{n-1}{k-1}_q\]</span> 故 <span class="math display">\[\begin{aligned}q^k\binom{n}{k}_q+\binom{n}{k-1}_q&amp;=q^k\frac{1-q^{n+1-k}}{1-q^{n+1}}\binom{n+1}{k}+\frac{1-q^k}{1-q^{n+1}}\binom{n+1}{k}\\&amp;=\left(\frac{q^k-q^{n+1}+1-q^{k}}{1-q^{n+1}}\right)\binom{n+1}{k}\\&amp;=\binom{n+1}{k}\end{aligned}\]</span></p><p>同理可得 <span class="math display">\[\binom{n}{k}+q^{n+1-k}\binom{n}{k-1}=\binom{n+1}{k}\]</span></p><p>显然可以用数学归纳法证明：</p><p><span class="math inline">\(n=1\)</span>显然。</p><p>设<span class="math inline">\(n=m\)</span>成立，那么当<spanclass="math inline">\(n=m+1\)</span>时，有： <spanclass="math display">\[\begin{aligned}&amp;(x+y)(x+qy)\cdots(x+q^{m-1}y)(x+q^my)\\&amp;=(x+q^my)\sum_{k=0}^{m}q^{\binom{k}{2}} \binom{m}{k}_qx^{m-k}y^k\\&amp;=\sum_{k=0}^{m}q^{\binom{k}{2}}\binom{m}{k}_qx^{m+1-k}y^k+\sum_{k=1}^{m+1}q^{\binom{k-1}{2}}q^m\binom{m}{k-1}_qx^{m+1-k}y^k\\&amp;=\binom{m}{0}_qx^{m+1} +\sum_{k=1}^{m}\left(\left(q^{\binom{k}{2}}\binom{m}{k}_q+q^{\binom{k-1}{2}+m} \binom{m}{k-1}_q\right)x^{m+1-k}y^k\right)+q^{\binom{m}{2}+\binom{m}{1}} \binom{m}{m}_qy^{m+1}\\&amp;=\binom{m+1}{0}_qx^{m+1}+\sum_{k=1}^{m}\left(q^{\binom{k}{2}}\left(\binom{m}{k}_q+q^{m+1-k}\binom{m}{k-1}_q \right)x^{m+1-k}y^k\right)+q^{\binom{m+1}{2}}y^{m+1}\\&amp;=\sum_{k=0}^{m+1}q^{\binom{k}{2}}\binom{m+1}{k}_qx^{m+1-k}y^k\end{aligned}\]</span> 证毕。</p><h2 id="section-13">50</h2><blockquote><p><img src="/images/image-20240929131531914.png"alt="image-20240929131531914" /> <imgsrc="/images/image-20240929131603989.png"alt="image-20240929131603989" /></p></blockquote><p>有 <span class="math display">\[\begin{aligned}g_n&amp;=\sum_{k=1}^{n} \binom{n-k}{k-1}\\&amp;=\sum_{k=1}^{n}\binom{n-k-1}{k-1}+\sum_{k=1}^{n}\binom{n-k-1}{k-2}\\&amp;=\sum_{k=1}^{n-1}\binom{n-1-k}{k-1}+\sum_{k=1}^{n}\binom{n-2-(k-1)}{k-1-1}\\&amp;=g_{n-1}+\sum_{k=0}^{n-1}\binom{n-2-k}{k-1}\\&amp;=g_{n-1}+\sum_{k=1}^{n-2}\binom{n-2-k}{k-1}\\&amp;=g_{n-1}+g_{n-2}\end{aligned}\]</span></p><h2 id="section-14">51</h2><blockquote><figure><img src="/images/image-20240929134343436.png"alt="image-20240929134343436" /><figcaption aria-hidden="true">image-20240929134343436</figcaption></figure></blockquote><p>有 <span class="math display">\[(1-3x)g(x)=2-4\sum_{n=1}^{\infty}nx^n\]</span> 故 <span class="math display">\[\begin{aligned}g(x)&amp;=\frac{2}{1-3x}-\frac{4}{1-3x} \sum_{n=1}^{\infty}nx^n\\&amp;=\frac{2}{1-3x}-\frac{4x}{1-3x}\sum_{n=0}^{\infty}\binom{n+1}{n}x^n\\&amp;=\frac{2}{1-3x}-\frac{4x}{1-3x}\frac{1}{(1-x)^2}\\&amp;=\frac{-1}{1-3x} + \frac{3-x}{(1-x)^2} \\&amp;=\sum_{n=0}^{\infty} (2n+3-3^n)x^n\end{aligned}\]</span></p>]]></content>
    
    
    
    <tags>
      
      <tag>combinatorics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5thCombinatorics6</title>
    <link href="/2024/09/30/5thCombinatorics6/"/>
    <url>/2024/09/30/5thCombinatorics6/</url>
    
    <content type="html"><![CDATA[<h1id="组合数学第五版答案-容斥原理及其应用">组合数学第五版答案-容斥原理及其应用</h1><blockquote><p>Richard A. Brualdi-Introductory Combinatorics (5th Edition) (2009)第六章的部分习题答案，直接套公式，书中有详细答案或与书中例题基本一致的题目省略。仅供参考。</p></blockquote><p>因本人水平有限，且没有标答验证，可能有错误，欢迎指正。</p><h2 id="section">3</h2><blockquote><p>Find the number of integers between 1 and 10,000 that are neitherperfect squares nor perfect cubes.</p></blockquote><p>如何找出既是完全平方数又是完全立方数的数？ 注意到<spanclass="math inline">\(x=a^2=b^3\)</span> 那么<spanclass="math inline">\(b=a^{\frac{2}{3}}\)</span>因此<spanclass="math inline">\(a^{\frac{1}{3}}\)</span>为整数,那么<spanclass="math inline">\(x=c^6\)</span>只需解<spanclass="math inline">\(c^6\leq10000\)</span>即可。</p><h2 id="section-1">19</h2><blockquote><p>Using the evaluation of the derangement numbers as given in Theorem6.3.1, provide a proof of the relation</p><p><span class="math display">\[D_n = (n-1)(D_{n-2} + D_{n-1}), \quad (n=3,4,5, ...).\]</span></p></blockquote><p><span class="math display">\[\begin{aligned}(n-1)(D_{n-1}+D_{n-2})&amp;=(n-1)\left((n-1)!\sum_{i=0}^{n-1}\frac{(-1)^i}{i!}+(n-2)!\sum_{i=0}^{n-2}\frac{(-1)^i}{i!}\right)\\&amp;=(n-1)\left((n-1)!+(n-2)!\right)\sum_{i=0}^{n-2}\frac{(-1)^i}{i!}+(n-1)\cdot(-1)^{n-1}\\&amp;=n!\sum_{i=0}^{n-2}\frac{(-1)^i}{i!}+n!\left(\frac{(-1)^{n-1}(n-1)}{n!}\right)\\&amp;=n!\sum_{i=0}^{n-2}\frac{(-1)^i}{i!}+n!\left(\frac{(-1)^{n-1}n}{n!}-(-1)^{n-1}\frac{1}{n!}\right)\\&amp;=D_n\end{aligned}\]</span></p><h2 id="section-2">21</h2><blockquote><p>Prove that <span class="math inline">\(D_n\)</span> is an even numberif and only if n is an odd number.</p></blockquote><p>可通过归纳法，或者：</p><p>可以根据 <span class="math display">\[D_n=n!\left(1-\frac{1}{1!}+\frac{1}{2!}-\frac{1}{3!}+\cdots+(-1)^n\frac{1}{n!}\right)\]</span> 单独考虑<span class="math inline">\(D_1\)</span>,然后 <spanclass="math display">\[D_n=(-1)^n \frac{n!}{n!} +(-1)^{n-1} \frac{n!}{(n-1)!}\cdots\]</span> 当<spanclass="math inline">\(n&gt;1\)</span>时，第三项后面项全是偶数，而第一项为奇数，第二项与n同奇偶，因此<spanclass="math inline">\(D_n\)</span>为偶数，当且仅当<spanclass="math inline">\(n\)</span>为奇数。</p><p>或者由于 <span class="math display">\[D_n=nD_{n-1}+(-1)^n\]</span> 递推一步，可得出： <span class="math display">\[D_{n+1}\equiv n(n+1)D_{n-1}+n \equiv n\mod{2}\]</span></p><h2 id="section-3">27</h2><blockquote><p>A carousel has eight seats, each representing a different animal.Eight girls are seated on the carousel facing forward (each girl ooks atanother girl's back). In how many ways can the girls change seats sothat each has a different girl in front of her? How does the problemchange if all the seats are identical?</p></blockquote><p>记<span class="math inline">\(A_i\)</span>表示排列<spanclass="math inline">\(s_1s_2 \cdots s_8\)</span>中<spanclass="math inline">\(s_i\)</span>面向<spanclass="math inline">\(s_{i+1}\)</span>（其中<spanclass="math inline">\(1 \le i \le 7\)</span>），<spanclass="math inline">\(A_8\)</span>表示表示排列<spanclass="math inline">\(s_1s_2 \cdots s_8\)</span>中<spanclass="math inline">\(s_8\)</span>面向<spanclass="math inline">\(s_1\)</span>。</p><p>单独考虑<span class="math inline">\(s_8\)</span>对<spanclass="math inline">\(s_1\)</span>的情况。</p><p><span class="math inline">\(|A_i|\)</span>：<spanclass="math inline">\(7!+6!=8\times 6!\)</span></p><p><span class="math inline">\(|A_iA_j|\)</span>：<spanclass="math inline">\(6!+2\times 5!=8\times 5!\)</span></p><p><span class="math inline">\(k\)</span>个相交为<spanclass="math inline">\((8-k)!+k\times(7-k)!=8\times (7-k)!\)</span></p><p>答案为13000</p><p>当所有座位都相同时，第一个选择的只有1种选法，其余人选法不变，因此排列总数为<spanclass="math inline">\(\frac{13000}{8} = 1625\)</span>。</p><h2 id="section-4">32</h2><blockquote><p>Let n be a positive integer and let<spanclass="math inline">\(p_1,p_2,\cdots,p_k\)</span>be all the differentprime numbers that divide n. Consider the Euler function <spanclass="math inline">\(\phi\)</span> defined by <spanclass="math display">\[\phi(n)=|\{k:1 \leq k\leq n,GCD(k,n)=1 \}|\]</span> Use the inclusion-exclusion principle to show that <spanclass="math display">\[\phi(n)=n\prod_{i=1}^{k} (1-\frac{1}{p_i})\]</span></p></blockquote><p>设<span class="math inline">\(A_i\)</span>为<spanclass="math inline">\(p_i|\gcd(k,n)\)</span>的集合。 <spanclass="math display">\[\begin{aligned}\phi(n)&amp;=|\overline{A_1}\cap \overline{A_2}\cap\cdots\cap\overline{A_k}|\\&amp;=n-\sum_{i}\left(\frac{n}{p_i}\right)+\sum_{i,j}\left(\frac{n}{p_ip_j}\right)-\cdots+(-1)^k(\frac{n}{p_1p_2\cdotsp_k})\\&amp;=n\prod_{i=1}^{k} (1-\frac{1}{p_i})\end{aligned}\]</span></p><h2 id="section-5">33</h2><blockquote><figure><img src="/images/image-20240824225321055.png"alt="image-20240824225321055" /><figcaption aria-hidden="true">image-20240824225321055</figcaption></figure></blockquote><p>等价于从围成一圈的<spanclass="math inline">\(1,2,\cdots,2n\)</span>选择不相邻的<spanclass="math inline">\(m\)</span>个数字。我们选出分成<spanclass="math inline">\(2n-k\)</span>和<spanclass="math inline">\(k\)</span>，从<spanclass="math inline">\(2n-k\)</span>中选出<spanclass="math inline">\(k\)</span>个空，每一种选择可进行旋转，有<spanclass="math inline">\(\frac{2n}{2n-k}\)</span>种。所以 <spanclass="math display">\[a(n,k)=\frac{2n}{2n-k} \binom{2n-k}{k}\]</span> 或者：</p><p>若不考虑<spanclass="math inline">\(1，2n\)</span>，我们可以假设选择<spanclass="math inline">\(c_1,c_2,\cdots,c_k\)</span>，其中小于<spanclass="math inline">\(c_i\)</span>的有<spanclass="math inline">\(x_i\)</span>个，大于<spanclass="math inline">\(c_k\)</span>的有<spanclass="math inline">\(x_{k+1}\)</span>个。那么我们有 <spanclass="math display">\[x_1+x_2+\cdots +x_{k+1}=2n-k\]</span> 然后先在两两中间插入一个，转化为 <span class="math display">\[y_1+y_2+\cdots+y_{k+1}=2n-2k+1\]</span> 其中<span class="math inline">\(0\leq y_i\leq 2n-2k+1\)</span>，有<span class="math inline">\(\binom{2n-k+1}{k}\)</span></p><p>假设选择<span class="math inline">\(2n\)</span>，那么 不能选择<spanclass="math inline">\(1,2n-1\)</span>,有<spanclass="math inline">\(\binom{2n-k-1}{k-1}\)</span></p><p>若不选择<span class="math inline">\(2n\)</span>，那么有<spanclass="math inline">\(\binom{2n-k}{k}\)</span></p><p>总数为 <span class="math display">\[\binom{2n-k-1}{k-1}+\binom{2n-k}{k}=\frac{k}{2n-k}\binom{2n-k}{k}+\binom{2n-k}{k}=\frac{2n}{2n-k}\binom{2n-k}{k}\]</span></p><blockquote><p>不知道为什么棋盘和下面的等价，带入k=1，显然是错的，可能是这些位置不是禁止，而是其他位置禁止，那么就显然等价了。</p><p>我们可以进行编号。例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1200</span><br><span class="hljs-number">0340</span><br><span class="hljs-number">0056</span><br><span class="hljs-number">8007</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="section-6">34</h2><blockquote><figure><img src="/images/image-20240824225329592.png"alt="image-20240824225329592" /><figcaption aria-hidden="true">image-20240824225329592</figcaption></figure></blockquote><p>交换求和次序即可。 <span class="math display">\[\begin{aligned}f*(g*h)(x,y)&amp;=\sum_{x\leq z\leq y}f(x,z)(g*h)(z,y)\\&amp;=\sum_{x\leq z\leq y}\left( f(x,z)\left(\sum_{z\leq w\leqy}g(z,w)h(w,y) \right)\right)\\&amp;=\sum_{x\leq z\leq y} \left(\sum_{z\leq w\leq y}f(x,z)g(z,w)h(w,y)\right)\\&amp;=\sum_{x\leq w\leq y}\left(\sum_{x\leq z\leq w}f(x,z)g(z,w)\right)h(w,y)\\&amp;=\sum_{x\leq w\leq y}(f*g)(x,w)h(w,y)\\&amp;=(f*g)*h\end{aligned}\]</span></p><h2 id="section-7">36</h2><blockquote><figure><img src="/images/image-20240824225335976.png"alt="image-20240824225335976" /><figcaption aria-hidden="true">image-20240824225335976</figcaption></figure></blockquote><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[<span class="hljs-number">30</span>][<span class="hljs-number">30</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> n;<br>  cin &gt;&gt; n;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>      cin &gt;&gt; a[i][j];<br>    &#125;<br>  &#125;<br>  ll ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1ll</span> &lt;&lt; n); ++i) &#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; S;<br>    <span class="hljs-comment">// subset S</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (i &gt;&gt; j &amp; <span class="hljs-number">1</span>) &#123;<br>        S.<span class="hljs-built_in">push_back</span>(j + <span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>    ll p = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; ++k) &#123;<br>      ll sum = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; x : S) sum += a[k][x];<br>      p *= sum;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((n - S.<span class="hljs-built_in">size</span>()) &amp; <span class="hljs-number">1</span>) &#123;<br>      ans -= p;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      ans += p;<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-8">37</h2><blockquote><figure><img src="/images/image-20240824225341561.png"alt="image-20240824225341561" /><figcaption aria-hidden="true">image-20240824225341561</figcaption></figure></blockquote><p>赋值法。</p><p>设<span class="math inline">\(f*g=\delta\)</span> <spanclass="math display">\[\delta(A,B)=\sum_{A\subseteq C \subseteq B} f(A,C) g(C,B)\]</span></p><ul><li><p>若<span class="math inline">\(A=B\)</span>：</p><p>那么 <span class="math display">\[f(A,A)g(A,A)=1\Rightarrow g(A,A)=1\]</span> <span class="math inline">\(g(A,B)=1\)</span></p></li><li><p>若<span class="math inline">\(|B|-|A|=1\)</span></p><p>那么 <span class="math display">\[\begin{aligned}0&amp;=f(A,A)g(A,B)+f(A,B)g(B,B)\\&amp;=g(A,B)+2\end{aligned}\]</span> <span class="math inline">\(g(A,B)=-2\)</span></p></li><li><p>若<span class="math inline">\(|B|-|A|=2\)</span></p><p>那么 <span class="math display">\[\begin{aligned}0&amp;=f(A,A)g(A,B)+f(A,C)g(C,B)+f(A,B)g(B,B) \\&amp;=g(A,B)+2g(C,B)+1\\&amp;=g(A,B)-4+1\end{aligned}\]</span> <span class="math inline">\(g(A,B)=3\)</span></p></li><li><p>若<span class="math inline">\(|B|-|A|=3\)</span></p><p>那么 <span class="math display">\[\begin{aligned}0&amp;=f(A,A)g(A,B)+f(A,C)g(C,B)+f(A,D)g(D,B)+f(A,B)g(B,B) \\&amp;=g(A,B)+2g(C,B)+g(D,B)-1 \\&amp;=g(A,B)+6-2-1\\\end{aligned}\]</span> <span class="math inline">\(g(A,B)=-3\)</span></p></li></ul><p>综上</p><p>若<span class="math inline">\(A\subseteq B\)</span> <spanclass="math display">\[g(A,B)=\begin{cases}1&amp;\qquad,A=B\\-2&amp;\qquad,|B|-|A|=1\\3&amp;\qquad,|B|-|A|=2\\-3&amp;\qquad,|B|-|A|=3\end{cases}\]</span></p><h2 id="section-9">38</h2><blockquote><figure><img src="/images/image-20240824225346059.png"alt="image-20240824225346059" /><figcaption aria-hidden="true">image-20240824225346059</figcaption></figure></blockquote><p>以<span class="math inline">\(\Pi_3\)</span>为例： <spanclass="math display">\[\begin{aligned}\sigma_1&amp;=\{\{ 1,2,3\}\}\\\sigma_2&amp;=\{\{ 1\},\{ 2,3\}\}\\\sigma_3&amp;=\{\{ 1,2\},\{ 3\}\}\\\sigma_4&amp;=\{\{ 1,3\},\{ 2\}\}\\\sigma_5&amp;=\{\{ 1\},\{ 2\},\{3\}\}\\\end{aligned}\]</span></p><ul><li><p>若<span class="math inline">\(|\sigma|-|\pi|=1\)</span> <spanclass="math display">\[\begin{aligned}\mu(\sigma,\pi)=-\left(\mu(\sigma,\sigma )\right)=-1\end{aligned}\]</span></p></li><li><p>若<span class="math inline">\(|\sigma|-|\pi|=2\)</span> <spanclass="math display">\[\mu(\sigma,\pi)=-\left(\mu(\sigma,\sigma)+\mu(\sigma,\sigma_2)+\mu(\sigma,\sigma_3)+\mu(\sigma,\sigma_4)\right)=-(1-3)=2\]</span></p></li></ul><h2 id="section-10">39</h2><blockquote><figure><img src="/images/image-20240824225352287.png"alt="image-20240824225352287" /><figcaption aria-hidden="true">image-20240824225352287</figcaption></figure></blockquote><p>等价于证明<span class="math inline">\(\forall a\in X_n,\mu(1,k)=\mu(a,ka)\)</span>对任意正整数成立(满足<spanclass="math inline">\(ka\leq n\)</span>)</p><p>考虑使用数学归纳法</p><ul><li><p><span class="math inline">\(k=1\)</span>,显然成立</p></li><li><p>假设对于任意<span class="math inline">\(x\leq t-1\)</span>成立。<span class="math display">\[\begin{aligned}\mu(1,t)&amp;=-\sum_{x|t,x&lt;t}\mu(1,x)\\&amp;=-\sum_{x|t,x&lt;t}\mu(a,xa)\\&amp;=\mu(a,ta)\end{aligned}\]</span></p></li></ul><p>证毕。</p><h2 id="section-11">40</h2><blockquote><figure><img src="/images/image-20240824225358425.png"alt="image-20240824225358425" /><figcaption aria-hidden="true">image-20240824225358425</figcaption></figure></blockquote><p>这里略过证明偏序关系的过程。</p><p>这个偏序集是<spanclass="math inline">\(k\)</span>个线性有序集的笛卡尔积。因此可以得到</p><p>设<span class="math inline">\(A=p_i\cdot a_i\)</span>，<spanclass="math inline">\(B=q_i\cdot a_i\)</span>，<spanclass="math inline">\(A\leq B\)</span>，<spanclass="math inline">\(m=\max_{1\leq i \leq k}{(q_i-p_i)}\)</span>，<spanclass="math inline">\(c=\sum_{1\leq i\leq k}[q_i-p_i=1]\)</span> <spanclass="math display">\[\mu(A,B)=\begin{cases}1&amp;\qquad,m=0\\(-1)^c&amp;\qquad,m=1\\0&amp;\qquad,m&gt;1\end{cases}\]</span></p>]]></content>
    
    
    
    <tags>
      
      <tag>combinatorics</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
